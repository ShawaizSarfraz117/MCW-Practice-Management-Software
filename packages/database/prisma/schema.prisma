// [Source: 1]
generator client {
  provider = "prisma-client-js"
}

generator fabbrica {
  provider    = "prisma-fabbrica"
  output      = "../src/generated/fabbrica"
  noTranspile = "true"
}

datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

/// Core appointment entity representing scheduled sessions, events, or meetings between clinicians and client groups.
/// Appointments are always associated with a ClientGroup (not individual clients) to support family/couple therapy.
model Appointment {
  id                       String             @id @default(dbgenerated("newid()"), map: "PK_Appointment_ID") @db.UniqueIdentifier // [Source: 2]
  /// Type of appointment: 'APPOINTMENT' (client sessions), 'EVENT' (non-client activities like staff meetings). Refer to schema_notes.md section 8.3 for defined values.
  type                     String             @db.VarChar(50)
  /// Display title for the appointment (e.g., "Family Therapy Session", "Staff Meeting"). Used when distinct from PracticeService.name/description (see schema_notes.md 7.2.3).
  title                    String?            @db.VarChar(255) // [Source: 3]
  /// Whether this spans the entire day (affects calendar display)
  is_all_day               Boolean            @default(false, map: "DF_Appointment_IsAllDay")
  /// Start date/time in UTC. All timestamps are stored in UTC.
  start_date               DateTime
  /// End date/time in UTC. All timestamps are stored in UTC.
  end_date                 DateTime
  /// Physical location where appointment takes place
  location_id              String?            @db.UniqueIdentifier // [Source: 4, 5]
  /// User who created this appointment record
  created_by               String             @db.UniqueIdentifier
  /// Current status: 'SCHEDULED', 'COMPLETED', 'CANCELLED', 'NO_SHOW'. Refer to schema_notes.md section 8.3 for defined values.
  status                   String             @db.VarChar(100)
  /// Clinician providing the service
  clinician_id             String?            @db.UniqueIdentifier // [Source: 6]
  /// Base fee for the appointment in dollars (before adjustments). Stored as Decimal(10,2).
  appointment_fee          Decimal?           @db.Decimal(10,2)
  /// Type of service being provided (links to service catalog)
  service_id               String?            @db.UniqueIdentifier // [Source: 7, 8]
  /// Whether this is part of a recurring series
  is_recurring             Boolean            @default(false, map: "DF_Appointment_IsRecurring")
  /// iCalendar RRULE format string defining recurrence pattern (e.g., "FREQ=WEEKLY;COUNT=10;BYDAY=MO,WE"). See schema_notes.md section 4.2.2 and Glossary (13) for 'Recurring Rule'.
  recurring_rule           String?            @db.Text // [Source: 9]
  /// Whether to cancel future appointments when updating recurring series
  cancel_appointments      Boolean? // [Source: 10]
  /// Whether to send cancellation notifications
  notify_cancellation      Boolean? // [Source: 11]
  /// For recurring appointments: NULL if parent, parent's ID if child instance. Manages parent-child relationship for recurring series.
  recurring_appointment_id String?            @db.UniqueIdentifier // [Source: 12]
  /// Client group (family/couple/individual) receiving services. Every appointment is associated with a ClientGroup. (schema_notes.md 7.1.1 implies individuals are in single-member groups).
  client_group_id          String?            @db.UniqueIdentifier // [Source: 13]
  /// Session-specific fee adjustment in dollars (can be negative for discounts/credits). Stored as Decimal(10,2). See Glossary (13) for 'Adjustment'.
  adjustable_amount        Decimal?           @db.Decimal(10,2) // [Source: 14]
  /// Link to superbill if this appointment is included in one
  superbill_id             String?            @db.UniqueIdentifier // [Source: 15]
  /// Amount written off (not expected to be collected) in dollars. Stored as Decimal(10,2). See Glossary (13) for 'Write-off'.
  write_off                Decimal?           @db.Decimal(10,2) // [Source: 16]
  ClientGroup              ClientGroup?       @relation(fields: [client_group_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Appointment_ClientGroup") // [Source: 17]
  Clinician                Clinician?         @relation(fields: [clinician_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Appointment_Clinician") // [Source: 18]
  Location                 Location?          @relation(fields: [location_id], references: [id], map: "FK_Appointment_Location") // [Source: 19]
  PracticeService          PracticeService?   @relation(fields: [service_id], references: [id], map: "FK_Appointment_PracticeService") // [Source: 20]
  /// Self-referential relation for recurring appointments (parent-child hierarchy)
  Appointment              Appointment?       @relation("AppointmentToAppointment", fields: [recurring_appointment_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Appointment_RecurringAppointment") // [Source: 21]
  other_Appointment        Appointment[]      @relation("AppointmentToAppointment")
  Superbill                Superbill?         @relation(fields: [superbill_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Appointment_Superbill") // [Source: 22]
  User                     User               @relation(fields: [created_by], references: [id], map: "FK_Appointment_User")
  AppointmentNotes         AppointmentNotes[]
  AppointmentTag           AppointmentTag[]
  Invoice                  Invoice[]
  SurveyAnswers            SurveyAnswers[] // [Source: 23]
}

/// Many-to-many junction table linking appointments with categorization tags
model AppointmentTag {
  id             String      @id(map: "PK_AppointmentTag_ID") @default(dbgenerated("newid()"), map: "DF_AppointmentTag_ID") @db.UniqueIdentifier
  appointment_id String      @db.UniqueIdentifier
  tag_id         String      @db.UniqueIdentifier
  Appointment    Appointment @relation(fields: [appointment_id], references: [id], onUpdate: NoAction, map: "FK_AppointmentTag_Appointment")
  Tag            Tag         @relation(fields: [tag_id], references: [id], onUpdate: NoAction, map: "FK_AppointmentTag_Tag") // [Source: 24]

  @@unique([appointment_id, tag_id], map: "UQ_AppointmentTag_Appointment_Tag")
  @@index([appointment_id], map: "IX_AppointmentTag_appointment_id")
  @@index([tag_id], map: "IX_AppointmentTag_tag_id")
}

/// HIPAA compliance audit trail for tracking access and events related to protected health information (PHI).
model Audit {
  Id         String   @id(map: "PK_Audit_ID") @default(dbgenerated("newid()"), map: "DF_Audit_ID") @db.UniqueIdentifier
  /// Client whose data was accessed or affected (null for system-level events not specific to one client).
  client_id  String?  @db.UniqueIdentifier // [Source: 25]
  /// User who performed the action or triggered the event.
  user_id    String?  @db.UniqueIdentifier // [Source: 26]
  /// Timestamp of the event in UTC.
  datetime   DateTime @default(now(), map: "DF__Audit__datetime__17ED6F58") @db.DateTime
  /// Type of event (e.g., 'VIEW', 'UPDATE', 'DELETE', 'LOGIN_SUCCESS', 'PHI_ACCESS').
  event_type String?  @db.NChar(10) // [Source: 27] // Consider making this VarChar for more flexibility or an Enum.
  /// Human-readable description of the event (e.g., "Viewed client record", "Updated appointment X").
  event_text String   @db.NVarChar(255)
  /// Whether this event involves HIPAA-protected information, requiring stricter logging.
  is_hipaa   Boolean  @default(false, map: "DF_Audit_IsHipaa")
  Client     Client?  @relation(fields: [client_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Audit_Client") // [Source: 28]
  User       User?    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Audit_User") // [Source: 29]
}

/// Clinician availability windows for scheduling appointments.
/// Supports both one-time and recurring availability patterns.
/// Note: Default values for date/time fields are under review (schema_notes.md 5.5).
model Availability {
  id                    String                 @id @default(dbgenerated("newid()"), map: "PK_Availability_ID") @db.UniqueIdentifier
  clinician_id          String                 @db.UniqueIdentifier
  created_at            DateTime               @default(now(), map: "DF_Availability_CreatedAt") // [Source: 30]
  updated_at            DateTime               @updatedAt
  /// Whether this availability repeats according to recurring_rule.
  is_recurring          Boolean                @default(false, map: "DF_Availability_IsRecurring")
  /// iCalendar RRULE format for recurring availability (e.g., "FREQ=WEEKLY;BYDAY=MO,TU"). See schema_notes.md Glossary (13).
  recurring_rule        String?                @db.Text // [Source: 31, 32]
  /// Daily end time for this availability window (UTC if not a recurring all-day event). Default under review.
  end_time              DateTime               @default(now(), map: "DF_Availability_EndTime")
  /// Daily start time for this availability window (UTC if not a recurring all-day event). Default under review.
  start_time            DateTime               @default(now(), map: "DF_Availability_StartTime")
  /// Last date this availability is valid (inclusive, relevant for recurring or fixed-term availability). Default under review.
  end_date              DateTime               @default(now(), map: "DF_Availability_EndDate") // [Source: 33]
  /// First date this availability is valid (inclusive). Default under review.
  start_date            DateTime               @default(now(), map: "DF_Availability_StartDate")
  /// Display title (e.g., "Morning Hours", "Evening Availability")
  title                 String                 @db.Text // [Source: 34]
  /// Whether clients can request appointments during this time via portal.
  allow_online_requests Boolean                @default(false, map: "DF_Availability_AllowOnlineRequests")
  location_id           String                 @db.UniqueIdentifier
  Clinician             Clinician              @relation(fields: [clinician_id], references: [id], onUpdate: NoAction, map: "FK_Availability_Clinician") // [Source: 35]
  Location              Location               @relation(fields: [location_id], references: [id], onUpdate: NoAction, map: "FK_Availability_Location")
  /// Services that can be booked during this availability window.
  AvailabilityServices  AvailabilityServices[]

  @@index([clinician_id], map: "IX_Availability_clinician_id")
  @@index([start_time, end_time], map: "IX_Availability_time_range")
}

/// Individual client (patient) record - the core entity for a person receiving services.
/// Clients are grouped into ClientGroups for appointments and billing.
model Client {
  id                       String                     @id @default(dbgenerated("newid()"), map: "PK_Client_ID") @db.UniqueIdentifier // [Source: 36]
  legal_first_name         String                     @db.VarChar(100)
  legal_last_name          String                     @db.VarChar(100) // [Source: 37]
  /// Whether client is on the practice's waitlist for services.
  is_waitlist              Boolean                    @default(false, map: "DF_Client_IsWaitlist")
  /// Primary clinician assigned to this client.
  primary_clinician_id     String?                    @db.UniqueIdentifier // [Source: 38]
  /// Primary location where client receives services.
  primary_location_id      String?                    @db.UniqueIdentifier // [Source: 39]
  created_at               DateTime                   @default(now(), map: "DF__Client__created___2FFA0313")
  /// Soft delete flag - false means client is inactive/archived.
  is_active                Boolean                    @default(true, map: "DF_Client_IsActive")
  /// Name the client prefers to be called.
  preferred_name           String?                    @db.VarChar(100) // [Source: 40, 41]
  /// Date of birth, stored as Date only.
  date_of_birth            DateTime?                  @db.Date // [Source: 42]
  /// Portal permission: can request appointments online.
  allow_online_appointment Boolean                    @default(false, map: "DF_Client_allow_online_appointment")
  /// Portal permission: can view invoices, statements, superbills.
  access_billing_documents Boolean                    @default(false, map: "DF_Client_access_billing_documents")
  /// Portal permission: can send secure messages to clinician.
  use_secure_messaging     Boolean                    @default(false, map: "DF_Client_use_secure_messaging") // [Source: 43]
  /// Free text field for referral source. (Nature of this field - free text vs. link - is under review, see schema_notes.md 7.1.6).
  referred_by              String?                    @db.VarChar(200) // [Source: 44]
  Audit                    Audit[]
  Clinician                Clinician?                 @relation(fields: [primary_clinician_id], references: [id], onUpdate: NoAction, map: "FK_Client_Clinician") // [Source: 45]
  Location                 Location?                  @relation(fields: [primary_location_id], references: [id], onUpdate: NoAction, map: "FK_Client_Location") // [Source: 46]
  ClientAdress             ClientAdress[]
  ClientContact            ClientContact[]
  ClientFiles              ClientFiles[]
  ClientGroupMembership    ClientGroupMembership[]
  /// One-to-one extended profile information.
  ClientProfile            ClientProfile? // [Source: 47]
  ClientReminderPreference ClientReminderPreference[]
  ClinicianClient          ClinicianClient[]
  CreditCard               CreditCard[]
  DiagnosisTreatmentPlan   DiagnosisTreatmentPlan[]
  GoodFaithEstimate        GoodFaithEstimate[]
  SurveyAnswers            SurveyAnswers[]
}

/// Extended demographic and personal information for a client.
/// Separated from main Client table to keep core data lean. Consider defining enums for fields like gender, status (schema_notes.md 5.2).
model ClientProfile {
  id                     String  @id @default(dbgenerated("newid()"), map: "PK_ClientProfile_ID") @db.UniqueIdentifier // [Source: 48]
  client_id              String  @unique @db.UniqueIdentifier
  middle_name            String? @db.VarChar(50) // [Source: 49]
  /// Biological sex assigned at birth. (Consider enum; schema_notes.md 5.2)
  gender                 String? @db.VarChar(50) // [Source: 50]
  /// How the client identifies their gender. (Consider enum; schema_notes.md 5.2)
  gender_identity        String? @db.VarChar(50) // [Source: 51]
  /// Current relationship status. (Consider enum; schema_notes.md 5.2)
  relationship_status    String? @db.VarChar(50) // [Source: 52]
  /// Current employment situation. (Consider enum; schema_notes.md 5.2)
  employment_status      String? @db.VarChar(50) // [Source: 53]
  /// JSON array of race/ethnicity selections.
  race_ethnicity         String? @db.Text // [Source: 54]
  /// Additional details if "Other" selected for race/ethnicity.
  race_ethnicity_details String? @db.VarChar(50) // [Source: 55]
  /// Client's preferred language for communication.
  preferred_language     String? @db.VarChar(50) // [Source: 56]
  /// General notes about the client.
  notes                  String? @db.Text // [Source: 57]
  Client                 Client  @relation(fields: [client_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientProfile_Client")
}

/// Physical addresses associated with a client.
/// Note: Typo in table name (Adress vs Address) preserved for compatibility. `address_line2` is optional.
model ClientAdress {
  id            String  @id @default(dbgenerated("newid()"), map: "PK_ClientAddress_ID") @db.UniqueIdentifier
  client_id     String  @db.UniqueIdentifier
  address_line1 String  @db.VarChar(255)
  address_line2 String? @db.VarChar(255) // [Source: 58]
  zip_code      String  @db.VarChar(50)
  city          String  @db.VarChar(50)
  state         String  @db.VarChar(50)
  country       String  @db.VarChar(50)
  /// Whether this is the client's primary address.
  is_primary    Boolean @default(false, map: "DF_ClientAddress_IsPrimary")
  Client        Client  @relation(fields: [client_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientAddress_Client")
}

/// Contact methods for a client (email, phone, etc.).
/// Distinction between `contact_type` and `type` should be clearly maintained (see schema_notes.md 5.3.2, 7.1.5).
model ClientContact {
  id                       String                     @id @default(dbgenerated("newid()"), map: "PK_ClientContact_ID") @db.UniqueIdentifier // [Source: 59]
  client_id                String                     @db.UniqueIdentifier
  /// Whether this is the primary contact method of its specific type (e.g. primary email, primary mobile).
  is_primary               Boolean                    @default(false, map: "DF_ClientContact_IsPrimary") // [Source: 60]
  /// Permission level: who can use this contact (e.g., 'CLIENT_ONLY', 'EMERGENCY_CONTACT_ONLY', 'SHARED_WITH_GROUP'). (Consider enum)
  permission               String                     @db.VarChar(50)
  /// Category of contact method: 'EMAIL', 'PHONE', 'SMS'. (Consider enum)
  contact_type             String                     @db.VarChar(50) // [Source: 61]
  /// Subcategory or usage label for the contact method: 'HOME', 'WORK', 'MOBILE', 'OTHER'. (Consider enum)
  type                     String                     @db.VarChar(50)
  /// The actual contact value (e.g., email address or phone number).
  value                    String                     @db.VarChar(255) // [Source: 62]
  Client                   Client                     @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_ClientContact_Client")
  ClientReminderPreference ClientReminderPreference[]
}

/// Groups of clients for scheduling and billing purposes. Every appointment is associated with a ClientGroup.
/// Types: 'individual' (single client), 'couple', 'family', 'minor' (child with guardian(s)). Refer to schema_notes.md section 8.3.
model ClientGroup {
  id                             String                     @id(map: "PK_ClientGroup_ID") @db.UniqueIdentifier
  /// Group type: 'individual', 'couple', 'family', 'minor'. Refer to schema_notes.md section 8.3 for defined values.
  type                           String                     @db.VarChar(150) // [Source: 64]
  /// Display name for the group (e.g., "Smith Family", "John & Jane Doe").
  name                           String                     @db.VarChar(250)
  /// Primary clinician for this group.
  clinician_id                   String?                    @db.UniqueIdentifier // [Source: 65, 66]
  /// Soft delete flag.
  is_active                      Boolean                    @default(true, map: "DF_ClientGroup_IsActive")
  /// Available credit balance in dollars that can be applied to future services. Stored as Decimal(10,2). Cannot be negative. See Glossary (13) for 'Available Credit'.
  available_credit               Decimal                    @db.Decimal(10,2) @default(0) // [Source: 67]
  created_at                     DateTime?                  @default(now(), map: "ClientGroup_created_at") // [Source: 68]
  /// Whether to automatically generate monthly statements for this group.
  auto_monthly_statement_enabled Boolean?                   @default(false, map: "DF_ClientGroup_auto_monthly_statement_enabled") // [Source: 69]
  /// Whether to automatically generate monthly superbills for insurance for this group.
  auto_monthly_superbill_enabled Boolean?                   @default(false, map: "DF_ClientGroup_auto_monthly_superbill_enabled") // [Source: 70]
  /// Date of first appointment for this group.
  first_seen_at                  DateTime?                  @default(now(), map: "ClientGroup_first_seen_at") // [Source: 71]
  /// General notes about this client group.
  notes                          String?                    @db.Text // [Source: 72]
  Appointment                    Appointment[]
  ClientBillingPreferences       ClientBillingPreferences[] // Note: Schema implies one-to-one via ClientBillingPreferences.client_group_id @unique
  Clinician                      Clinician?                 @relation(fields: [clinician_id], references: [id], onUpdate: NoAction, map: "FK_ClientGroup_Clinician") // [Source: 73]
  ClientGroupFile                ClientGroupFile[]
  ClientGroupMembership          ClientGroupMembership[]
  ClientGroupServices            ClientGroupServices[]
  Invoice                        Invoice[]
  Statement                      Statement[] // [Source: 74]
  Superbill                      Superbill[]
}

/// Junction table defining which clients belong to which groups and their roles within the group.
model ClientGroupMembership {
  client_group_id            String      @db.UniqueIdentifier // Removed default here, should be part of composite PK
  client_id                  String      @db.UniqueIdentifier
  /// Role within the group (e.g., 'Primary', 'Spouse', 'Child', 'Guardian'). See schema_notes.md 4.1, 7.1.3.
  role                       String?     @db.VarChar(50) // [Source: 75, 76]
  created_at                 DateTime    @default(now(), map: "DF__GroupClie__creat__6EEB59C5")
  /// Whether this person is only a contact (not receiving services directly as a patient, e.g., an emergency contact or guardian who is not the patient). See schema_notes.md 4.1, 7.1.4 and Glossary (13) for 'Contact-Only'.
  is_contact_only            Boolean     @default(false, map: "DF_ClientGroupMembership_IsContactOnly")
  /// Whether this member is responsible for paying bills for the group. Only one member can be responsible per group.
  is_responsible_for_billing Boolean? // [Source: 77]
  /// Whether this person should be contacted in emergencies.
  is_emergency_contact       Boolean?    @default(false, map: "DF_ClientGroupMembership_IsEmergencyContactOnly") // [Source: 78]
  Client                     Client      @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_ClientGroupMembership_Client")
  ClientGroup                ClientGroup @relation(fields: [client_group_id], references: [id], onUpdate: NoAction, map: "FK_ClientGroupMembership_ClientGroup")

  @@id([client_group_id, client_id], map: "PK_ClientGroupMembership_ID")
  @@index([client_id], map: "IX_ClientGroupMembership_client_id")
}

/// Client preferences for receiving various types of reminders and notifications by channel.
model ClientReminderPreference {
  id            String        @id @default(dbgenerated("newid()"), map: "PK_ClientReminderPreference_ID") @db.UniqueIdentifier // [Source: 79]
  client_id     String        @db.UniqueIdentifier
  /// Type of reminder: e.g., 'APPOINTMENT_CONFIRMATION', 'APPOINTMENT_REMINDER', 'DOCUMENT_DUE', 'BILLING_NOTIFICATION', 'CANCELLATION_NOTICE'. (Consider enum)
  reminder_type String        @db.VarChar(100)
  /// Whether this reminder type and channel combination is enabled for the client.
  is_enabled    Boolean       @default(true, map: "DF_ClientReminderPreference_IsEnabled")
  /// Delivery channel: 'EMAIL', 'SMS', 'VOICE'. (Consider enum)
  channel       String        @db.VarChar(50) // Added VarChar limit
  /// Which ClientContact record (verified email/phone) to use for this reminder.
  contact_id    String        @db.UniqueIdentifier // [Source: 80]
  Client        Client        @relation(fields: [client_id], references: [id], onDelete: Cascade, map: "FK_ClientReminderPreference_Client")
  ClientContact ClientContact @relation(fields: [contact_id], references: [id], onDelete: Cascade, map: "FK_ClientReminderPreference_ClientContact") // onDelete: Cascade might be too aggressive if contact is deleted. Revisit.

  @@unique([client_id, reminder_type, channel])
}

/// Billing addresses for a clinician's practice.
/// Types: 'PRACTICE' (main office), 'MAILING' (for correspondence). Each clinician should have one of each type as needed.
model BillingAddress {
  id           String    @id @default(dbgenerated("newid()"), map: "PK_BillingAddress_ID") @db.UniqueIdentifier
  street       String    @db.VarChar(255)
  city         String    @db.VarChar(100) // [Source: 81]
  state        String    @db.VarChar(50)
  zip          String    @db.VarChar(20)
  /// Address type: 'PRACTICE' or 'MAILING'. (Consider enum)
  type         String    @db.VarChar(50)
  clinician_id String    @db.UniqueIdentifier
  Clinician    Clinician @relation("ManyBillingAddresses", fields: [clinician_id], references: [id], onDelete: Cascade, map: "FK_BillingAddress_Clinician")

  @@unique([clinician_id, type], map: "UQ_BillingAddress_Clinician_Type")
  @@index([clinician_id], map: "IX_BillingAddress_clinician_id")
}

/// Healthcare provider (clinician) who delivers services to clients.
/// Linked 1:1 with a User account for system authentication.
model Clinician {
  id                  String                @id @default(dbgenerated("newid()"), map: "PK_Clinician_ID") @db.UniqueIdentifier // [Source: 82]
  /// Link to user account for authentication. Each clinician is linked to exactly one user account.
  user_id             String                @unique @db.UniqueIdentifier
  /// Full practice address (consider deprecating in favor of structured Location and BillingAddress entities).
  address             String                @db.Text // [Source: 83]
  /// Revenue split percentage for this clinician (e.g., 0.6 for 60%).
  percentage_split    Float
  /// Soft delete flag.
  is_active           Boolean               @default(true, map: "DF_Clinician_IsActive")
  first_name          String                @db.VarChar(100) // [Source: 84]
  last_name           String                @db.VarChar(100)
  /// Medical specialty or area of practice (e.g., 'Psychology', 'LCSW'). (Overlap with ClinicalInfo, schema_notes.md 5.3.1)
  speciality          String?               @db.VarChar(250) // [Source: 85]
  /// National Provider Identifier - unique ID for healthcare providers in the US. Stored as String. (Overlap with ClinicalInfo, schema_notes.md 5.3.1)
  NPI_number          String?               @db.VarChar(250) // [Source: 86]
  /// Classification code for the clinician's specialty for insurance billing (e.g., '103K00000X'). (Overlap with ClinicalInfo, schema_notes.md 5.3.1)
  taxonomy_code       String?               @db.VarChar(250) // [Source: 87]
  Appointment         Appointment[]
  appointmentLimits   AppointmentLimit[]
  Availability        Availability[]
  billingAddresses    BillingAddress[]      @relation("ManyBillingAddresses")
  /// One-to-one billing configuration for this clinician.
  billingSettings     BillingSettings? // [Source: 88]
  Client              Client[]
  ClientGroup         ClientGroup[]
  User                User                  @relation(fields: [user_id], references: [id], map: "FK_Clinician_User")
  ClinicianClient     ClinicianClient[]
  ClinicianLocation   ClinicianLocation[]
  ClinicianServices   ClinicianServices[]
  GoodFaithEstimate   GoodFaithEstimate[]
  Invoice             Invoice[] // [Source: 89]
  License             License[]
  PracticeInformation PracticeInformation[]
}

/// Many-to-many relationship between clinicians and clients.
/// Tracks which clinicians work with which clients, and who is primary.
model ClinicianClient {
  client_id     String    @db.UniqueIdentifier
  clinician_id  String    @db.UniqueIdentifier
  /// Whether this is the client's primary clinician.
  is_primary    Boolean   @default(false, map: "DF_ClinicianClient_IsPrimary")
  /// When this clinician-client relationship was established.
  assigned_date DateTime  @default(now(), map: "DF__Clinician__assig__430CD787")
  Client        Client    @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_ClinicianClient_Client") // [Source: 90]
  Clinician     Clinician @relation(fields: [clinician_id], references: [id], onUpdate: NoAction, map: "FK_ClinicianClient_Clinician")

  @@id([client_id, clinician_id], map: "PK_ClinicianClient_ID")
}

/// Many-to-many relationship between clinicians and practice locations they operate from.
model ClinicianLocation {
  clinician_id String    @db.UniqueIdentifier
  location_id  String    @db.UniqueIdentifier
  /// Whether this is the clinician's primary practice location.
  is_primary   Boolean   @default(false, map: "DF_ClinicianLocation_IsPrimary")
  Clinician    Clinician @relation(fields: [clinician_id], references: [id], map: "FK_ClinicianLocation_Clinician")
  Location     Location  @relation(fields: [location_id], references: [id], map: "FK_ClinicianLocation_Location") // [Source: 91]

  @@id([clinician_id, location_id], map: "PK_ClinicianLocation_ID")
}

/// Services offered by specific clinicians with optional custom rates that override standard service rates.
model ClinicianServices {
  clinician_id    String          @db.UniqueIdentifier
  service_id      String          @db.UniqueIdentifier
  /// Custom rate in dollars for this clinician providing this service. Stored as Decimal(10,2).
  custom_rate     Decimal?        @db.Decimal(10,2) // [Source: 92]
  /// Whether this clinician currently offers this service.
  is_active       Boolean         @default(true, map: "DF_ClinicianServices_IsActive")
  Clinician       Clinician       @relation(fields: [clinician_id], references: [id], map: "FK_ClinicianServices_Clinician")
  PracticeService PracticeService @relation(fields: [service_id], references: [id], map: "FK_ClinicianServices_PracticeService")

  @@id([clinician_id, service_id], map: "PK_ClinicianServices_ID")
}

/// Tokenized credit card information for payment processing.
/// Actual card numbers are never stored - only tokens from the payment processor.
model CreditCard {
  id              String    @id @default(dbgenerated("newid()"), map: "PK_CreditCard_ID") @db.UniqueIdentifier // [Source: 93]
  client_id       String    @db.UniqueIdentifier
  /// Card network: 'VISA', 'MASTERCARD', 'AMEX', 'DISCOVER', etc. (Consider enum)
  card_type       String    @db.VarChar(50)
  /// Last four digits of card number for identification.
  last_four       String    @db.VarChar(4)
  expiry_month    Int       // e.g., 12 for December
  expiry_year     Int       // e.g., 2025
  cardholder_name String    @db.VarChar(100)
  /// Whether this is the default payment method for the client.
  is_default      Boolean   @default(false, map: "DF_CreditCard_IsDefault") // [Source: 94]
  /// Billing address associated with this card (e.g., street, city, zip). Stored as text, consider structured fields or link to an Address entity.
  billing_address String?   @db.Text // [Source: 95]
  /// Payment processor token for secure transactions. This should be unique.
  token           String?   @db.VarChar(255) @unique // [Source: 96]
  created_at      DateTime  @default(now(), map: "DF__CreditCar__creat__01FE2E39")
  Client          Client    @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_CreditCard_Client") // Consider if onDelete should be SetNull or Restrict
  Payment         Payment[]
}

/// Financial charges for services rendered or products sold.
/// Can be linked to appointments or created independently (e.g., for products).
model Invoice {
  id                  String       @id @default(dbgenerated("newid()"), map: "PK_Invoice_ID") @db.UniqueIdentifier
  /// Sequential invoice number for display (e.g., "INV-000123"). Should be unique.
  invoice_number      String       @db.VarChar(50) @unique // [Source: 97]
  /// Client group being billed. Optional if billing is not group-specific (e.g. direct product sale to an individual not in a group context).
  client_group_id     String?      @db.UniqueIdentifier // [Source: 98]
  /// Optional link to a specific appointment if the invoice is for that session. Null if for products or multiple sessions (if not itemized).
  appointment_id      String?      @db.UniqueIdentifier // [Source: 99]
  /// Clinician who provided the service or is associated with the sale.
  clinician_id        String?      @db.UniqueIdentifier // [Source: 100]
  /// Date invoice was created/issued, in UTC.
  issued_date         DateTime     @default(now(), map: "DF__Invoice__issued___7D39791C")
  /// Payment due date, in UTC.
  due_date            DateTime
  /// Total amount due in dollars. Stored as Decimal(10,2).
  amount              Decimal      @db.Decimal(10, 2)
  /// Current status: 'UNPAID', 'PAID', 'PARTIAL', 'CREDIT', 'VOID'. Refer to schema_notes.md section 8.3 for defined values.
  status              String       @db.VarChar(50) // [Source: 101]
  /// Invoice type: 'INVOICE' (standard charge), 'ADJUSTMENT' (modification), 'CREDIT' (credit note). Refer to schema_notes.md section 4.3.1.
  type                String       @db.VarChar(50)
  /// Formatted client information for invoice display (consider generating at runtime or storing structured refs).
  client_info         String?      @db.Text // [Source: 102]
  /// Additional notes for the invoice (e.g., payment instructions, internal remarks).
  notes               String?      @db.Text // [Source: 103]
  /// Formatted provider information for invoice display (consider generating at runtime or storing structured refs).
  provider_info       String?      @db.Text // [Source: 104]
  /// Description of services/products provided (can be a summary if line items are not used).
  service_description String?      @db.Text // [Source: 105]
  /// Whether this invoice has been exported to an external accounting system.
  is_exported         Boolean      @default(false, map: "DF_Invoice_is_exported")
  Appointment         Appointment? @relation(fields: [appointment_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Invoice_Appointment") // [Source: 106]
  ClientGroup         ClientGroup? @relation(fields: [client_group_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Invoice_ClientGroup") // [Source: 107]
  Clinician           Clinician?   @relation(fields: [clinician_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Invoice_Clinician") // [Source: 108]
  Payment             Payment[]
  // Consider adding InvoiceItem[] relation if detailed line items are needed (schema_notes.md 10.1.1)
}

/// Physical locations where services are provided or practice operates.
model Location {
  id                String              @id @default(dbgenerated("newid()"), map: "PK_Location_ID") @db.UniqueIdentifier
  /// Display name for the location (e.g., "Downtown Office", "Telehealth Platform").
  name              String              @db.VarChar(255) // [Source: 109]
  /// Full address (consider deprecating in favor of structured fields below if `street`, `city`, etc. are always filled).
  address           String              @db.Text
  /// Whether this location is currently active and can be used for scheduling.
  is_active         Boolean             @default(true, map: "DF_Location_IsActive")
  city              String?             @db.VarChar(100) // [Source: 110]
  /// Hex color code for calendar display to visually distinguish appointments at this location.
  color             String?             @db.VarChar(50) // [Source: 111] Example: #FF0000
  state             String?             @db.VarChar(100) // [Source: 112]
  street            String?             @db.VarChar(255) // [Source: 113]
  zip               String?             @db.VarChar(20) // [Source: 114]
  Appointment       Appointment[]
  Availability      Availability[]
  Client            Client[]            // For primary_location_id
  ClinicianLocation ClinicianLocation[]
  GoodFaithEstimate GoodFaithEstimate[] // For clinician_location_id
  GoodFaithServices GoodFaithServices[] // For GFS specific location
}

/// Payment transactions made against invoices.
model Payment {
  id             String      @id @default(dbgenerated("newid()"), map: "PK_Payment_ID") @db.UniqueIdentifier
  invoice_id     String      @db.UniqueIdentifier // The invoice this payment is applied to.
  /// Date payment was processed/received, in UTC.
  payment_date   DateTime    @default(now(), map: "DF__Payment__payment__05CEBF1D") // [Source: 115]
  /// Payment amount in dollars. Stored as Decimal(10,2).
  amount         Decimal     @db.Decimal(10, 2)
  /// Credit card used for this payment, if applicable.
  credit_card_id String?     @db.UniqueIdentifier // [Source: 116]
  /// External transaction ID from payment processor (e.g., Stripe tx_********).
  transaction_id String?     @db.VarChar(100) // [Source: 117]
  /// Payment status: 'PENDING', 'COMPLETED', 'FAILED', 'REFUNDED'. Refer to schema_notes.md section 8.3 for defined values.
  status         String      @db.VarChar(50)
  /// Raw response or relevant details from payment processor for logging/debugging.
  response       String?     @db.Text // [Source: 118]
  /// Amount of client's available credit (from ClientGroup) applied to this payment, in dollars. Stored as Decimal(10,2).
  credit_applied Decimal?    @db.Decimal(10,2) // [Source: 119]
  CreditCard     CreditCard? @relation(fields: [credit_card_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Payment_CreditCard")
  Invoice        Invoice     @relation(fields: [invoice_id], references: [id], onUpdate: NoAction, map: "FK_Payment_Invoice") // Consider Restrict if payments should prevent invoice deletion.
}

/// Catalog of services offered by the practice.
model PracticeService {
  id                  String                @id @default(dbgenerated("newid()"), map: "PK_PracticeService_ID") @db.UniqueIdentifier
  /// Service name for display (e.g., "Individual Therapy 50 min", "Couples Counseling"). Consider renaming field to `name`.
  type                String                @db.VarChar(255) // [Source: 120]
  /// Standard rate in dollars for this service. Stored as Decimal(10,2).
  rate                Decimal               @db.Decimal(10, 2)
  /// Service code (e.g., CPT code like 90834, or internal code) for billing. Should be unique.
  code                String                @db.VarChar(50) @unique // [Source: 121]
  /// Detailed description of the service.
  description         String?               @db.Text // [Source: 122]
  /// Standard duration of the service in minutes.
  duration            Int
  /// Hex color code for calendar display to visually distinguish appointments for this service.
  color               String?               @db.VarChar(7) // [Source: 123] Example: #00FF00
  /// Whether new clients are allowed to book this service.
  allow_new_clients   Boolean               @default(false)
  /// Whether this service can be booked online via the client portal.
  available_online    Boolean               @default(false)
  /// Whether to bill insurance in units (e.g., 15-minute increments for some codes).
  bill_in_units       Boolean               @default(false)
  /// Buffer time in minutes to automatically block on calendar after an appointment of this type.
  block_after         Int                   @default(0) // [Source: 124]
  /// Buffer time in minutes to automatically block on calendar before an appointment of this type.
  block_before        Int                   @default(0)
  /// Whether this is the default service selected when creating new appointments.
  is_default          Boolean               @default(false) // [Source: 125]
  /// Whether booking this service requires a phone call (cannot be booked directly online).
  require_call        Boolean               @default(false)
  Appointment         Appointment[]
  AppointmentRequests AppointmentRequests[]
  ClientGroupServices ClientGroupServices[]
  ClinicianServices   ClinicianServices[]
  GoodFaithServices   GoodFaithServices[]
}

/// User roles for role-based access control (RBAC) within the system.
model Role {
  id             String           @id @default(dbgenerated("newid()"), map: "PK_Role_ID") @db.UniqueIdentifier // [Source: 126]
  /// Unique role identifier (e.g., 'ADMIN', 'CLINICIAN', 'STAFF', 'CLIENT'). See schema_notes.md 7.5.3.
  name           String           @unique @db.VarChar(255)
  /// Human-readable description of role permissions and responsibilities.
  description    String?          @db.Text // [Source: 127]
  RolePermission RolePermission[]
  UserRole       UserRole[]
}

/// Client responses to surveys, forms, and questionnaires. Linked to `SurveyTemplate` for structure.
/// Can be linked to an appointment or a client intake process.
model SurveyAnswers {
  id                     String                   @id(map: "PK_SurveyAnswers_ID") @default(dbgenerated("newid()"), map: "DF_SurveyAnswers_ID") @db.UniqueIdentifier
  /// Template this answer is based on, defining the questions and structure.
  template_id            String                   @db.UniqueIdentifier // [Source: 128]
  client_id              String                   @db.UniqueIdentifier // The client who completed/is associated with this survey.
  /// JSON content of the completed survey, storing answers to the questions from the template.
  content                String?                  @db.Text // [Source: 129]
  /// How often this survey should be completed (e.g., 'ONCE', 'AD_HOC', 'ANNUALLY'). Copied or set based on template.
  frequency              String?                  @db.NChar(10) // [Source: 130]
  /// When the client completed this survey, in UTC.
  completed_at           DateTime? // [Source: 131]
  /// When this survey was assigned to the client, in UTC.
  assigned_at            DateTime                 @default(now(), map: "DF__ClientDoc__assig__4D8A65FA")
  /// When this survey response expires or is no longer considered valid/current, in UTC.
  expiry_date            DateTime? // [Source: 132]
  /// Whether this is an intake form, often part of new client onboarding.
  is_intake              Boolean                  @default(false, map: "DF_SurveyAnswers_is_intake")
  /// Current status: 'ASSIGNED', 'IN_PROGRESS', 'COMPLETED', 'EXPIRED', 'SUBMITTED'. (Consider enum)
  status                 String                   @db.VarChar(100)
  /// Link to appointment if survey is specifically for that session (e.g., pre-session questionnaire).
  appointment_id         String?                  @db.UniqueIdentifier // [Source: 133]
  /// Whether the client (or clinician, if applicable) has digitally signed this document. See schema_notes.md 7.6.4, 9.3.
  is_signed              Boolean?                 @default(false) // [Source: 134] // Changed from Boolean? to Boolean @default(false)
  /// Whether this document is locked from further edits (e.g., after signing or finalization).
  is_locked              Boolean?                 @default(false) // [Source: 135] // Changed from Boolean? to Boolean @default(false)
  AppointmentNotes       AppointmentNotes[]       // Notes derived from or based on this survey.
  ClientFiles            ClientFiles[]            // If this survey answer is stored as a file itself.
  DiagnosisTreatmentPlan DiagnosisTreatmentPlan[] // If this survey is an assessment for a treatment plan.
  Appointment            Appointment?             @relation(fields: [appointment_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_SurveyAnswers_Appointment") // [Source: 136]
  Client                 Client                   @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_SurveyAnswers_Client")
  SurveyTemplate         SurveyTemplate           @relation(fields: [template_id], references: [id], onUpdate: NoAction, map: "FK_SurveyAnswers_SurveyTemplate")
}

/// Templates for surveys, forms, and questionnaires (e.g., intake forms, consent forms, assessments).
model SurveyTemplate {
  id                 String          @id(map: "PK_SurveyTemplate_ID") @default(dbgenerated("newid()"), map: "DF_SurveyTemplate_ID") @db.UniqueIdentifier // [Source: 137]
  /// Template name for display and selection (e.g., "Adult Intake Form", "Consent for Telehealth").
  name               String          @db.VarChar(255)
  /// JSON structure defining form fields, layout, and validation rules.
  content            String          @db.Text
  /// Recommended or typical frequency for completing this survey (e.g., 'ONCE', 'WEEKLY', 'MONTHLY', 'ANNUALLY').
  frequency_options  String?         @db.NChar(10) // [Source: 138] Consider more descriptive VarChar or Enum.
  /// Whether this template is available for use in assigning to clients.
  is_active          Boolean         @default(true, map: "DF_SurveyTemplate_IsActive")
  created_at         DateTime        @default(now(), map: "DF__DocumentT__creat__35B2DC69")
  /// Description of template purpose and intended use.
  description        String?         @db.Text // [Source: 139]
  updated_at         DateTime        @updatedAt // This should likely be @updatedAt
  /// Template type: 'INTAKE', 'CONSENT', 'ASSESSMENT', 'FEEDBACK', 'SCREENING'. See schema_notes.md 7.6.3.
  type               String          @db.VarChar(100)
  /// Whether this is the default template of its specific 'type'.
  is_default         Boolean         @default(false, map: "DF_SurveyTemplate_is_default")
  /// Whether this form requires a signature upon completion.
  requires_signature Boolean         @default(false, map: "DF_SurveyTemplate_RequiresSignature") // [Source: 140]
  /// Whether clients can access/initiate this form via the client portal.
  is_shareable       Boolean         @default(false, map: "DF_SurveyTemplate_is_shareable")
  SurveyAnswers      SurveyAnswers[]
}

/// System table for SQL Server diagram storage (auto-generated by SSMS, can often be ignored by Prisma).
model sysdiagrams {
  name         String @db.NVarChar(128)
  principal_id Int
  diagram_id   Int    @id(map: "PK_sysdiagrams_ID") @default(autoincrement())
  version      Int?
  definition   Bytes? // [Source: 141]

  @@unique([principal_id, name], map: "UK_principal_name")
}

/// Categorization tags for appointments (e.g., "Initial Consultation", "Crisis Intervention", "Telehealth Session").
model Tag {
  id             String           @id(map: "PK_Tag_ID") @default(dbgenerated("newid()"), map: "DF_Tag_ID") @db.UniqueIdentifier
  /// Tag name for display. Should be unique.
  name           String           @db.NVarChar(100) @unique
  /// Hex color code for visual distinction in UI components (e.g., calendars, lists).
  color          String?          @db.NVarChar(50) // [Source: 142] Example: #A020F0
  AppointmentTag AppointmentTag[]
}

/// System users who can log into the application.
/// Includes clinicians, staff, and administrators. Client portal access is managed separately via Client entity flags.
model User {
  id            String            @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// Login email address, must be unique.
  email         String            @unique @db.VarChar(255)
  /// Hashed password using a strong hashing algorithm (never store plain text).
  password_hash String            @db.VarChar(255) // [Source: 143]
  /// Last successful login timestamp, in UTC.
  last_login    DateTime? // [Source: 144]
  /// User's date of birth (optional).
  date_of_birth DateTime?         @db.Date
  /// User's primary phone number (optional).
  phone         String?           @db.VarChar(20) // [Source: 145]
  /// URL to user's profile photo (optional).
  profile_photo String?           @db.VarChar(500) // [Source: 146]
  Appointment   Appointment[]     // Appointments created by this user.
  Audit         Audit[]           // Audit trail records associated with this user.
  ClientGroupFile ClientGroupFile[] // Files uploaded by this user.
  /// Legacy clinical info - actively being consolidated into Clinician fields. Avoid new usage. See schema_notes.md 5.3.1, 7.5.2.
  clinicalInfos ClinicalInfo[]
  /// One-to-one relationship with Clinician if this user is a healthcare provider.
  Clinician     Clinician? // [Source: 147]
  Statement     Statement[]       // Statements created by this user.
  Superbill     Superbill[]       // Superbills created by this user.
  UserRole      UserRole[]        // Roles assigned to this user.
}

/// Many-to-many junction table linking users to their assigned roles.
model UserRole {
  user_id String @db.UniqueIdentifier
  role_id String @db.UniqueIdentifier
  Role    Role   @relation(fields: [role_id], references: [id], map: "FK_UserRole_Role") // onDelete: Cascade if roles are deleted, user loses role.
  User    User   @relation(fields: [user_id], references: [id], map: "FK_UserRole_User") // onDelete: Cascade if user is deleted, their role assignments are removed.

  @@id([user_id, role_id], map: "PK_UserRole_ID")
}

/// Legacy table for clinical information. Data should be migrated to fields in the Clinician model.
/// Contains duplicate or overlapping fields with Clinician. NPI number type mismatch noted.
model ClinicalInfo {
  id            Int     @id @default(autoincrement()) // [Source: 148]
  /// Clinician's specialty. (Migrate to Clinician.speciality)
  speciality    String
  /// National Provider Identifier. (Migrate to Clinician.NPI_number, ensuring String type). Note: Type here is Float, Clinician is String. String is preferred.
  NPI_number    Float  // This should be String to match Clinician.NPI_number and NPI format.
  /// Taxonomy code. (Migrate to Clinician.taxonomy_code)
  taxonomy_code String
  /// Link to the User account. This field should be unique if a user has only one ClinicalInfo record.
  user_id       String  @db.UniqueIdentifier @unique
  User          User    @relation(fields: [user_id], references: [id], map: "FK_clinicalInfo_User") // onDelete: Cascade if user is deleted.
}

/// Professional licenses held by clinicians, required for practice in specific jurisdictions.
model License {
  id              String    @id(map: "PK_License") @default(dbgenerated("newid()"), map: "DF_License_id") @db.UniqueIdentifier // [Source: 149]
  clinician_id    String    @db.UniqueIdentifier
  /// Type of license (e.g., 'LCSW', 'LMFT', 'PhD', 'MD'). (Consider enum)
  license_type    String    @db.VarChar(100) // Increased length
  /// State-issued license number.
  license_number  String    @db.VarChar(100) // Increased length
  /// License expiration date for renewal tracking, stored as Date only.
  expiration_date DateTime  @db.Date // Changed to Date
  /// State or jurisdiction where license is valid (e.g., two-letter US state code 'CA', 'NY').
  state           String    @db.VarChar(50) // Increased length
  Clinician       Clinician @relation(fields: [clinician_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_License_Clinician") // [Source: 150] // onDelete: Cascade if clinician is removed.
}

/// Practice-wide information and global settings.
/// Consider consolidating with the key-value PracticeSettings table if appropriate (schema_notes.md suggests for PI).
model PracticeInformation {
  id             String     @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// Optional: Link to a primary clinician or owner if settings are practice-specific but tied to an individual. Generally, these are practice-wide.
  clinician_id   String?    @db.UniqueIdentifier // [Source: 151]
  /// Official name of the practice.
  practice_name  String     @db.VarChar(255) // Increased length
  /// Primary contact email for the practice.
  practice_email String     @db.VarChar(255) // Increased length
  /// IANA timezone for the practice (e.g., 'America/New_York', 'Europe/Vienna').
  time_zone      String     @db.VarChar(100) // Increased length
  /// URL to the practice's logo image.
  practice_logo  String     @db.VarChar(500) // Increased length, type to Text if very long
  /// JSON array of practice phone numbers, e.g., [{type: "Main", number: "555-1234"}, {type: "Fax", number: "555-5678"}].
  phone_numbers  String     @db.Text // Changed to Text for JSON flexibility
  /// Whether the practice generally offers telehealth services.
  tele_health    Boolean
  Clinician      Clinician? @relation(fields: [clinician_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_PracticeInformation_Clinician") // [Source: 152]
}

/// Daily appointment limits for clinicians to prevent overbooking.
model AppointmentLimit {
  id           String    @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// Date this limit applies to, stored as Date only.
  date         DateTime  @db.Date
  /// Maximum number of appointments this clinician can have on this specific date.
  max_limit    Int       @default(10)
  clinician_id String    @db.UniqueIdentifier
  Clinician    Clinician @relation(fields: [clinician_id], references: [id], onDelete: Cascade, onUpdate: NoAction) // onDelete: Cascade if clinician is removed.

  @@unique([date, clinician_id], name: "UQ_AppointmentLimit_Date_Clinician") // [Source: 153]
  @@index([clinician_id], map: "IX_AppointmentLimit_clinician_id")
  @@index([date], map: "IX_AppointmentLimit_date")
}

/// Email notification templates with dynamic content placeholders (merge tags).
/// Merge tag processing logic is application-side (see schema_notes.md 4.4, 7.4.1).
model EmailTemplate {
  id         String   @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// Template name for internal reference (e.g., "appointment_reminder_24hr"). Unique.
  name       String   @db.VarChar(255) @unique
  /// Email subject line (supports merge tags like {{client_full_name}}, {{appointment_date}}).
  subject    String   @db.VarChar(255)
  /// Email body HTML/text (supports merge tags).
  content    String   @db.Text
  /// Template category: 'AUTOMATED', 'REMINDER', 'BILLING', 'ACCOUNT_MANAGEMENT'. See schema_notes.md 7.4.2. (Consider enum)
  type       String   @db.VarChar(50) // [Source: 154]
  /// Target audience: 'CLIENT' (primary patient), 'CONTACT' (e.g., guardian, spouse), 'COUPLE' (both members). See schema_notes.md 7.4.2. (Consider enum)
  email_type String?  @db.VarChar(250) // [Source: 155]
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  /// User who created this template.
  created_by String   @db.UniqueIdentifier // Should relate to User model if tracking creator.

  @@index([type])
  @@index([created_by])
}

/// Products that can be sold to clients (e.g., supplements, books, workshops).
/// Invoicing for products needs clarification (schema_notes.md 7.3.6).
model Product {
  id    String  @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// Product name for display.
  name  String  @db.VarChar(255)
  /// Price in dollars. Stored as Decimal(10,2).
  price Decimal @db.Decimal(10, 2)
  // Consider adding fields like description, SKU, stock_quantity if inventory is managed.
}

/// Granular permissions that can be assigned to roles for RBAC.
model Permission {
  id             String           @id @default(dbgenerated("newid()")) @db.UniqueIdentifier // [Source: 156]
  /// Human-readable permission name (e.g., "View Client Records", "Edit Billing Information").
  name           String           @db.VarChar(255)
  /// System identifier for permission (e.g., 'clients.view', 'billing.edit', 'appointments.create'). Must be unique.
  slug           String           @unique @db.VarChar(100)
  RolePermission RolePermission[]
}

/// Many-to-many junction table linking roles to their granted permissions.
model RolePermission {
  role_id       String     @db.UniqueIdentifier
  permission_id String     @db.UniqueIdentifier // [Source: 157]
  Permission    Permission @relation(fields: [permission_id], references: [id], onDelete: Cascade, map: "FK_RolePermission_Permission") // onDelete: Cascade if permission is deleted.
  Role          Role       @relation(fields: [role_id], references: [id], onDelete: Cascade, map: "FK_RolePermission_Role")          // onDelete: Cascade if role is deleted.

  @@id([role_id, permission_id], map: "PK_RolePermission_ID")
  @@index([role_id], map: "IX_RolePermission_role_id")
  @@index([permission_id], map: "IX_RolePermission_permission_id")
}

/// Files uploaded for or shared with a client group (e.g., shared documents, forms to be completed).
/// See schema_notes.md 7.6.1 for workflow with ClientFiles.
model ClientGroupFile {
  id                 String        @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// Link to a survey template if this file represents a form to be completed by group members.
  survey_template_id String?       @db.UniqueIdentifier // [Source: 158, 159]
  /// File title for display (e.g., "Group Therapy Guidelines", "Intake Packet").
  title              String        @db.VarChar(255)
  /// File type: 'PRACTICE_UPLOAD' (e.g. informational doc from practice), 'CLIENT_UPLOAD' (doc uploaded by a client/group member), 'FORM' (a survey/form to be filled). (Consider enum)
  type               String        @default("PRACTICE_UPLOAD") @db.VarChar(50)
  /// URL to file storage location (e.g., S3 bucket URL).
  url                String?       @db.Text // [Source: 160]
  client_group_id    String        @db.UniqueIdentifier
  /// User who uploaded this file (if applicable, null if system-generated or anonymous upload).
  uploaded_by_id     String?       @db.UniqueIdentifier // [Source: 161]
  created_at         DateTime      @default(now())
  updated_at         DateTime      @updatedAt
  /// Tracks individual client access and status for this group file.
  ClientFiles        ClientFiles[]
  ClientGroup        ClientGroup   @relation(fields: [client_group_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientGroupFile_ClientGroup") // onDelete: Cascade if group is deleted.
  User               User?         @relation(fields: [uploaded_by_id], references: [id], onDelete: SetNull, onUpdate: NoAction, map: "FK_ClientGroupFile_User") // onDelete: SetNull to keep file record if uploader user is deleted. // [Source: 162]

  @@index([client_group_id], map: "IX_ClientGroupFile_client_group_id")
  @@index([uploaded_by_id], map: "IX_ClientGroupFile_uploaded_by_id")
}

/// Monthly statement summarizing account activity (invoices, payments, balances) for a client group.
model Statement {
  id                String          @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// Sequential statement number for the client group (e.g., STMT-001 for group A, STMT-002 for group A). Needs logic for sequencing per group.
  statement_number  Int             @default(0) // Consider if this should be String for formatting, or auto-increment per group.
  client_group_id   String          @db.UniqueIdentifier
  /// Start of statement period, in UTC.
  start_date        DateTime? // [Source: 163]
  /// End of statement period, in UTC.
  end_date          DateTime? // [Source: 164]
  /// Date statement was generated, in UTC.
  issued_date       DateTime?       @default(now()) // [Source: 165] // Default to now()
  /// Balance at start of period, in dollars. Stored as Decimal(10,2).
  beginning_balance Decimal         @db.Decimal(10, 2)
  /// Total charges (from invoices) during period, in dollars. Stored as Decimal(10,2).
  invoices_total    Decimal         @db.Decimal(10, 2)
  /// Total payments received during period, in dollars. Stored as Decimal(10,2).
  payments_total    Decimal         @db.Decimal(10, 2)
  /// Balance at end of period (beginning_balance + invoices_total - payments_total), in dollars. Stored as Decimal(10,2).
  ending_balance    Decimal         @db.Decimal(10, 2)
  /// Provider name for statement header (can be practice name).
  provider_name     String?         @db.VarChar(255) // [Source: 167]
  provider_email    String?         @db.VarChar(255)
  provider_phone    String?         @db.VarChar(255) // [Source: 168]
  /// Client group name for statement header.
  client_group_name String          @db.VarChar(255)
  /// Primary client name for mailing/identification.
  client_name       String          @db.VarChar(255)
  client_email      String?         @db.VarChar(255) // [Source: 169]
  created_at        DateTime        @default(now())
  /// User who generated this statement (if manually generated).
  created_by        String?         @db.UniqueIdentifier // [Source: 170]
  /// Whether exported to an external accounting system.
  is_exported       Boolean         @default(false, map: "DF_Statement_is_exported")
  ClientGroup       ClientGroup     @relation(fields: [client_group_id], references: [id], onUpdate: NoAction, map: "FK_Statement_ClientGroup") // onDelete: Restrict or Cascade, depending on business rules for deleting groups with statements.
  User              User?           @relation(fields: [created_by], references: [id], onDelete: SetNull, onUpdate: NoAction, map: "FK_Statement_User") // onDelete: SetNull to keep statement if creator user is deleted. // [Source: 171]
  /// Line items showing individual transactions included in this statement.
  StatementItem     StatementItem[]

  @@index([client_group_id], map: "IX_Statement_client_group_id")
}

/// Itemized statement for insurance reimbursement, listing services provided with diagnosis codes. See Glossary (13) for 'Superbill'.
model Superbill {
  id               String        @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// Sequential superbill number for the client group. Needs logic for sequencing per group.
  superbill_number Int           @default(0) // Consider String for formatting.
  client_group_id  String        @db.UniqueIdentifier
  /// Date superbill was generated, in UTC.
  issued_date      DateTime      @default(now()) // [Source: 172]
  /// Provider information for insurance (practice name or clinician name).
  provider_name    String?       @db.VarChar(255) // [Source: 173]
  provider_email   String?       @db.VarChar(255)
  /// Provider's license number for insurance.
  provider_license String?       @db.VarChar(100) // [Source: 174]
  /// Client name for insurance claim (usually primary client in the group).
  client_name      String        @db.VarChar(255)
  /// Superbill status: 'DRAFT', 'FINAL', 'SUBMITTED_TO_CLIENT', 'VOID'. (Consider enum)
  status           String        @db.VarChar(50)
  created_at       DateTime      @default(now())
  /// User who generated this superbill.
  created_by       String?       @db.UniqueIdentifier // [Source: 175]
  /// Whether exported to an external billing system or provided to client.
  is_exported      Boolean       @default(false, map: "DF_Superbill_is_exported")
  /// Appointments included in this superbill. This is a many-to-many relation via Appointment.superbill_id.
  Appointment      Appointment[]
  ClientGroup      ClientGroup   @relation(fields: [client_group_id], references: [id], onUpdate: NoAction, map: "FK_Superbill_ClientGroup") // onDelete: Restrict or Cascade.
  User             User?         @relation(fields: [created_by], references: [id], onDelete: SetNull, onUpdate: NoAction, map: "FK_Superbill_User") // onDelete: SetNull. // [Source: 176]

  @@index([client_group_id], map: "IX_Superbill_client_group_id")
}

/// Billing configuration and preferences, can be global (clinician_id is null) or clinician-specific.
model BillingSettings {
  id                                   String     @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// If null, these are global practice settings. If set, clinician-specific overrides. The @unique constraint means only one record per clinician, or one global record if all clinician-specific records have an ID.
  clinician_id                         String?    @unique @db.UniqueIdentifier // [Source: 177]
  /// When to create invoices: 'MANUAL', 'ON_APPOINTMENT_COMPLETION', 'END_OF_DAY', 'WEEKLY', 'MONTHLY'. Based on this, auto-invoicing is triggered. (Consider enum)
  autoInvoiceCreation                  String?    @db.VarChar(50) // [Source: 178]
  /// Number of days after due_date before an invoice is marked as past due.
  pastDueDays                          Int? // [Source: 179]
  /// Whether to automatically email clients about past due invoices.
  emailClientPastDue                   Boolean? // [Source: 180]
  /// Whether to include practice logo on generated invoices.
  invoiceIncludePracticeLogo           Boolean? // [Source: 181]
  /// Custom footer text for invoices (e.g., payment terms, thank you note). Max 120 chars.
  invoiceFooterInfo                    String?    @db.VarChar(120) // [Source: 182]
  /// Day of the month (1-28) to automatically generate superbills if enabled for a client group.
  superbillDayOfMonth                  Int? // [Source: 183]
  /// Whether to include practice logo on generated superbills.
  superbillIncludePracticeLogo         Boolean? // [Source: 184]
  /// Whether to include a signature line on generated superbills.
  superbillIncludeSignatureLine        Boolean? // [Source: 185]
  /// Whether to include full diagnosis descriptions on superbills (not just codes).
  superbillIncludeDiagnosisDescription Boolean? // [Source: 186]
  /// Custom footer text for superbills. Max 120 chars.
  superbillFooterInfo                  String?    @db.VarChar(120) // [Source: 187]
  /// Delay in minutes before sending billing documents via email after generation (allows for review/cancellation).
  billingDocEmailDelayMinutes          Int?       @default(0) // [Source: 188]
  /// Default setting for new client groups: automatically enable monthly statements.
  createMonthlyStatementsForNewClients Boolean?   @default(false)
  /// Default setting for new client groups: automatically enable monthly superbills.
  createMonthlySuperbillsForNewClients Boolean?   @default(false) // [Source: 189]
  /// Default notification method for new billing documents: 'EMAIL', 'PORTAL_ONLY', 'BOTH'. (Consider enum)
  defaultNotificationMethod            String?    @db.VarChar(50) // [Source: 190]
  created_at                           DateTime   @default(now())
  updated_at                           DateTime   @updatedAt
  Clinician                            Clinician? @relation(fields: [clinician_id], references: [id], onDelete: Cascade) // [Source: 191] // onDelete: Cascade if clinician is removed, their specific settings are also removed.

  @@index([clinician_id])
}

/// Clinical notes linked to appointments (e.g., progress notes, SOAP notes).
/// Can be based on a completed survey/form.
model AppointmentNotes {
  id                 String        @id(map: "PK_AppointmentNotes") @db.UniqueIdentifier // Default value for ID?
  appointment_id     String        @db.UniqueIdentifier
  /// Note type: 'PROGRESS_NOTE', 'SOAP_NOTE', 'PRIVATE_NOTE' (clinician only), 'CONTACT_LOG'. See schema_notes.md 7.2.5. (Consider enum)
  type               String        @db.VarChar(50)
  /// Link to completed survey/form if this note is directly derived from or incorporates it.
  survey_answer_id   String?       @db.UniqueIdentifier // Made optional: A note might not always come from a survey // [Source: 192]
  /// User (clinician) who created the note.
  created_by         String?       @db.UniqueIdentifier // [Source: 193] // Should link to User
  /// Whether note has been signed/finalized by the clinician.
  is_signed          Boolean       @default(false, map: "DF_AppointmentNotes_is_signed")
  /// User who unlocked a previously signed note for editing (requires specific permissions).
  unlocked_by        String?       @db.UniqueIdentifier // [Source: 194] // Should link to User
  /// Timestamp when note was unlocked, in UTC.
  unlocked_time      DateTime? // [Source: 195]
  /// Name of person who signed the note (usually the clinician).
  signed_name        String?       @db.VarChar(250) // [Source: 196]
  /// Professional credentials of the signer (e.g., "LCSW", "PhD").
  signed_credentials String?       @db.VarChar(250) // [Source: 197]
  /// Timestamp when note was signed, in UTC.
  signed_time        DateTime? // [Source: 198]
  /// IP address recorded at the time of signing for audit trail.
  signed_ipaddress   String?       @db.VarChar(50) // [Source: 199]
  Appointment        Appointment   @relation(fields: [appointment_id], references: [id], onUpdate: NoAction, map: "FK_AppointmentNotes_Appointment") // onDelete: Cascade or Restrict.
  SurveyAnswers      SurveyAnswers? @relation(fields: [survey_answer_id], references: [id], onUpdate: NoAction, map: "FK_AppointmentNotes_SurveyAnswers") // onDelete: SetNull if survey is deleted but note remains.
  // Add relation to User for created_by and unlocked_by
}

/// Billing notification preferences for a client group. Unique per client_group_id.
model ClientBillingPreferences {
  id                         String      @id(map: "PK_ClientBillingPreferences") @db.UniqueIdentifier // Default value for ID?
  client_group_id            String      @db.UniqueIdentifier @unique // [Source: 200]
  /// Email invoices to the group's billing contact when generated.
  email_generated_invoices   Boolean     @default(false, map: "DF_ClientBillingPreferences_email_generated_invoices")
  /// Email statements to the group's billing contact when generated.
  email_generated_statements Boolean     @default(false, map: "DF_ClientBillingPreferences_email_generated_statements")
  /// Email superbills to the group's billing contact when generated.
  email_generated_superbills Boolean     @default(false, map: "DF_ClientBillingPreferences_email_generated_superbills")
  /// Send notifications (portal/other) for newly available invoices.
  notify_new_invoices        Boolean     @default(false, map: "DF_ClientBillingPreferences_notify_new_invoices")
  /// Send notifications for newly available statements.
  notify_new_statements      Boolean     @default(false, map: "DF_ClientBillingPreferences_notify_new_statements")
  /// Send notifications for newly available superbills.
  notify_new_superbills      Boolean     @default(false, map: "DF_ClientBillingPreferences_notify_new_superbills") // [Source: 201]
  ClientGroup                ClientGroup @relation(fields: [client_group_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientBillingPreferences_ClientGroup") // onDelete: Cascade if group is deleted.
}

/// Tracks which individual clients have access to/interacted with specific group files.
/// Allows individual tracking of document status (e.g., viewed, completed) per client for a file shared with a group. Unique per file and client.
model ClientFiles {
  id                   String          @id(map: "PK_ClientFiles") @db.UniqueIdentifier // Default value for ID?
  client_group_file_id String          @db.UniqueIdentifier // [Source: 202]
  client_id            String          @db.UniqueIdentifier
  /// File status for this specific client regarding this group file: 'PENDING_VIEW', 'VIEWED', 'ACTION_PENDING', 'COMPLETED', 'SIGNED'. (Consider enum)
  status               String          @db.VarChar(50)
  /// Link to survey response if this client completed a form associated with the ClientGroupFile. See schema_notes.md 7.6.2.
  survey_answers_id    String?         @db.UniqueIdentifier // [Source: 203]
  Client               Client          @relation(fields: [client_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientFiles_Client") // onDelete: Cascade.
  ClientGroupFile      ClientGroupFile @relation(fields: [client_group_file_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientFiles_ClientGroupFile") //onDelete: Cascade.
  SurveyAnswers        SurveyAnswers?  @relation(fields: [survey_answers_id], references: [id], onDelete: SetNull, onUpdate: NoAction, map: "FK_ClientFiles_SurveyAnswers") // onDelete: SetNull. // [Source: 204]

  @@unique([client_group_file_id, client_id])
}

/// Custom service rates for specific client groups, overriding standard practice service rates or clinician-specific rates.
/// Unique per group and service.
model ClientGroupServices {
  id              String          @id(map: "PK_ClientGroupServices") @db.UniqueIdentifier // Default value for ID?
  client_group_id String          @db.UniqueIdentifier
  service_id      String          @db.UniqueIdentifier
  /// Custom rate in dollars for this group for this specific service. Stored as Decimal(10,2).
  custom_rate     Decimal         @db.Decimal(10,2) // [Source: 205]
  ClientGroup     ClientGroup     @relation(fields: [client_group_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientGroupServices_ClientGroup") // onDelete: Cascade.
  PracticeService PracticeService @relation(fields: [service_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientGroupServices_PracticeService") // onDelete: Cascade.

  @@unique([client_group_id, service_id])
}

/// ICD-10 or DSM-5 diagnosis codes used for billing and treatment planning.
model Diagnosis {
  id                         String                       @id(map: "PK__Diagnosi__3213E83FF84A10BA") @default(dbgenerated("newid()"), map: "DF__Diagnosis__id__4F688CCB") @db.UniqueIdentifier // [Source: 206]
  /// Diagnosis code (e.g., 'F41.1' for GAD, '296.33' for MDD recurrent severe). Must be unique.
  code                       String                       @db.VarChar(50) @unique
  /// Full description of the diagnosis.
  description                String                       @db.VarChar(255) // [Source: 207]
  DiagnosisTreatmentPlanItem DiagnosisTreatmentPlanItem[]
  GoodFaithServices          GoodFaithServices[]

  @@index([code], map: "IX_Diagnosis_Code")
}

/// Treatment plans linking clients to diagnoses and outlining proposed care.
model DiagnosisTreatmentPlan {
  id                         String                       @id(map: "PK__Diagnosi__3213E83FDFE52E56") @default(dbgenerated("newid()"), map: "DF__DiagnosisTre__id__5244F976") @db.UniqueIdentifier
  client_id                  String                       @db.UniqueIdentifier // [Source: 208]
  created_at                 DateTime                     @default(now(), map: "DF__Diagnosis__creat__53391DAF") @db.DateTime
  updated_at                 DateTime?                    @updatedAt @db.DateTime // [Source: 209] // Added @updatedAt
  /// Whether plan has been signed by clinician and/or client. Consider Boolean.
  is_signed                  Boolean?                     @default(false) // [Source: 210] // Changed to Boolean? @default(false) from String?
  /// Treatment plan title (e.g., "Initial Treatment Plan for Anxiety").
  title                      String                       @db.VarChar(255)
  /// Link to completed assessment form (SurveyAnswers) that informed this treatment plan.
  survey_answers_id          String?                      @db.UniqueIdentifier // [Source: 211]
  Client                     Client                       @relation(fields: [client_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_DiagnosisTreatmentPlan_Client") // onDelete: Cascade.
  SurveyAnswers              SurveyAnswers?               @relation(fields: [survey_answers_id], references: [id], onDelete: SetNull, onUpdate: NoAction, map: "FK_DiagnosisTreatmentPlan_SurveyAnswers") // onDelete: SetNull. // [Source: 212]
  /// Individual diagnoses included in this treatment plan.
  DiagnosisTreatmentPlanItem DiagnosisTreatmentPlanItem[]

  @@index([client_id], map: "IX_DiagnosisTreatmentPlan_ClientId")
  @@index([survey_answers_id], map: "IX_DiagnosisTreatmentPlan_SurveyAnswersId")
}

/// Individual diagnosis items within a specific treatment plan.
model DiagnosisTreatmentPlanItem {
  id                     String                 @id(map: "PK__Diagnosi__3213E83F425BBD2A") @default(dbgenerated("newid()"), map: "DF__DiagnosisTre__id__58F1F705") @db.UniqueIdentifier
  treatment_plan_id      String                 @db.UniqueIdentifier // [Source: 213]
  diagnosis_id           String                 @db.UniqueIdentifier
  /// Additional notes or specifications for this diagnosis within the context of this treatment plan (e.g., severity, focus of treatment).
  custom_description     String?                @db.VarChar(255) // [Source: 214]
  Diagnosis              Diagnosis              @relation(fields: [diagnosis_id], references: [id], onDelete: Restrict, onUpdate: NoAction, map: "FK_DiagnosisTreatmentPlanItem_Diagnosis") // onDelete: Restrict - don't delete a diagnosis if it's in a plan.
  DiagnosisTreatmentPlan DiagnosisTreatmentPlan @relation(fields: [treatment_plan_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_DiagnosisTreatmentPlanItem_DiagnosisTreatmentPlan") // onDelete: Cascade if plan is deleted.

  @@index([diagnosis_id], map: "IX_DiagnosisTreatmentPlanItem_DiagnosisId")
  @@index([treatment_plan_id], map: "IX_DiagnosisTreatmentPlanItem_TreatmentPlanId")
}

/// Good Faith Estimate (GFE) for healthcare services, required by the No Surprises Act for uninsured or self-pay clients.
/// Uniqueness on (client_id, provided_date) is an example and needs business confirmation.
model GoodFaithEstimate {
  id                    String              @id(map: "PK_GoodFaithEstimate") @db.UniqueIdentifier // Default value?
  client_id             String              @db.UniqueIdentifier
  clinician_id          String              @db.UniqueIdentifier
  /// Client name as it should appear on the estimate.
  client_name           String?             @db.VarChar(100) // [Source: 216]
  /// Client's date of birth, stored as Date only.
  client_dob            DateTime?           @db.Date // [Source: 217]
  /// Client's full address.
  client_address        String?             @db.VarChar(250) // [Source: 218]
  client_city           String?             @db.VarChar(100) // [Source: 219]
  client_state          String?             @db.VarChar(100) // [Source: 220]
  /// Client's ZIP code, stored as string to preserve leading zeros. Changed from Int?.
  client_zip_code       String?             @db.VarChar(20) // [Source: 221]
  client_phone          String?             @db.VarChar(50) // [Source: 222]
  client_email          String?             @db.VarChar(100) // [Source: 223]
  /// Clinician's National Provider Identifier (NPI).
  clinician_npi         String?             @db.VarChar(100) // [Source: 224]
  /// Clinician's Tax Identification Number (TIN) or Employer Identification Number (EIN).
  clinician_tin         String?             @db.VarChar(100) // [Source: 225]
  /// Location where services will be primarily provided.
  clinician_location_id String              @db.UniqueIdentifier
  /// Contact person at the practice for questions about the GFE. Could be a User ID.
  contact_person_id     String?             @db.UniqueIdentifier // [Source: 226] // Link to User?
  clinician_phone       String?             @db.VarChar(50)
  clinician_email       String?             @db.VarChar(50) // [Source: 227]
  /// Date the estimate was provided to the client, in UTC.
  provided_date         DateTime?           @db.DateTime // [Source: 228]
  /// Date the estimate expires (typically 1 year from provided_date), in UTC.
  expiration_date       DateTime?           @db.DateTime // [Source: 229]
  /// Expected start date of the course of treatment covered by this GFE, as Date only.
  service_start_date    DateTime?           @db.Date // [Source: 230]
  /// Expected end date of the course of treatment covered by this GFE, as Date only.
  service_end_date      DateTime?           @db.Date // [Source: 231]
  /// Total estimated cost in dollars for all services listed. Stored as Decimal(10,2).
  total_cost            Decimal             @db.Decimal(10, 2)
  Client                Client              @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithEstimate_Client")
  Clinician             Clinician           @relation(fields: [clinician_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithEstimate_Clinician") // [Source: 232]
  Location              Location            @relation(fields: [clinician_location_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithEstimate_Location")
  /// Individual services included in this estimate.
  GoodFaithServices     GoodFaithServices[]

  @@unique([client_id, provided_date]) // Business rule confirmation needed for this exact unique key (schema_notes.md 3.2)
}

/// Individual service lines within a Good Faith Estimate.
model GoodFaithServices {
  id                String            @id(map: "PK_GoodFaithServices") @db.UniqueIdentifier // Default value? // [Source: 233]
  good_faith_id     String            @db.UniqueIdentifier // Link to the parent GFE.
  service_id        String            @db.UniqueIdentifier // Link to PracticeService.
  diagnosis_id      String            @db.UniqueIdentifier // Primary diagnosis code for this service line.
  location_id       String            @db.UniqueIdentifier // Location where this specific service is expected.
  /// Expected number of sessions or units for this service.
  quantity          Int // [Source: 234]
  /// Fee per session/unit in dollars for this service. Stored as Decimal(10,2).
  fee               Decimal           @db.Decimal(10, 2)
  Diagnosis         Diagnosis         @relation(fields: [diagnosis_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithServices_Diagnosis")
  GoodFaithEstimate GoodFaithEstimate @relation(fields: [good_faith_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_GoodFaithServices_GoodFaithEstimate") // onDelete: Cascade if GFE is deleted.
  Location          Location          @relation(fields: [location_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithServices_Location") // [Source: 235]
  PracticeService   PracticeService   @relation(fields: [service_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithServices_PracticeService")
}

/// Line items on a statement showing individual transactions (charges, payments, adjustments).
model StatementItem {
  id           String    @id(map: "PK_StatementItem") @db.UniqueIdentifier // Default value?
  statement_id String    @db.UniqueIdentifier
  /// Transaction date, as Date only.
  date         DateTime  @db.Date // Changed to Date
  /// Transaction description (e.g., "Invoice #INV-00123", "Payment - Visa ending 4321", "Adjustment - Late Fee").
  description  String    @db.VarChar(255)
  /// Charge amount in dollars (positive value, 0 if payment/credit). Stored as Decimal(10,2).
  charges      Decimal   @db.Decimal(10, 2) // [Source: 236]
  /// Payment or credit amount in dollars (positive value, 0 if charge). Stored as Decimal(10,2).
  payments     Decimal   @db.Decimal(10, 2)
  /// Running balance after this transaction, in dollars. Stored as Decimal(10,2).
  balance      Decimal   @db.Decimal(10, 2)
  Statement    Statement @relation(fields: [statement_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_StatementItem_Statement") // onDelete: Cascade if statement is deleted.
}

/// Requests for appointments submitted through client portal or other intake channels.
/// Used for new client intake and existing client appointment requests.
model AppointmentRequests {
  id                       String                @id(map: "PK_AppointmentRequests") @db.UniqueIdentifier // Default value? // [Source: 237]
  clinician_id             String                @db.UniqueIdentifier // Requested clinician.
  /// Null for new clients (details in RequestContactItems), populated for existing clients making a request.
  client_id                String?               @db.UniqueIdentifier // [Source: 238]
  service_id               String                @db.UniqueIdentifier // Requested service.
  /// Who the appointment is for: 'SELF', 'CHILD', 'OTHER_DEPENDENT'. (Consider enum)
  appointment_for          String?               @db.VarChar(50) // [Source: 239]
  /// Client's stated reasons for seeking care or purpose of the appointment.
  reasons_for_seeking_care String?               @db.Text // [Source: 240]
  /// Brief summary of previous therapy or mental health treatment, if any.
  mental_health_history    String?               @db.Text // [Source: 241]
  /// Any other information client wants to share with the request.
  additional_notes         String?               @db.Text // [Source: 242]
  /// Requested appointment start time, in UTC.
  start_time               DateTime              @db.DateTime
  /// Requested appointment end time, in UTC.
  end_time                 DateTime              @db.DateTime
  /// Request status: 'PENDING_REVIEW', 'ACCEPTED', 'DECLINED', 'CONVERTED_TO_APPOINTMENT'. Refer to schema_notes.md 4.2.1, 7.2.1. (Consider enum)
  status                   String                @db.VarChar(250) // [Source: 243]
  /// When request was submitted/received, in UTC.
  received_date            DateTime              @db.DateTime
  /// Last status update timestamp, in UTC.
  updated_at               DateTime?             @updatedAt @db.DateTime // [Source: 244] // Added @updatedAt
  PracticeService          PracticeService       @relation(fields: [service_id], references: [id], onUpdate: NoAction, map: "FK_AppointmentRequests_PracticeService")
  /// Contact information for new clients or individuals associated with the request.
  RequestContactItems      RequestContactItems[]
  // Link to Client model if client_id is present
  // Link to Clinician model for clinician_id
}

/// Defines which services can be booked during specific availability windows.
model AvailabilityServices {
  availability_id String       @db.UniqueIdentifier
  service_id      String       @db.UniqueIdentifier
  Availability    Availability @relation(fields: [availability_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_AvailabilityServices_Availability") // onDelete: Cascade.
  // Add relation to PracticeService once service_id is confirmed to link there. Assuming it does:
  PracticeService PracticeService @relation(fields: [service_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_AvailabilityServices_PracticeService")


  @@id([availability_id, service_id], map: "PK_AvailabilityServices")
}

/// Client portal configuration and settings, potentially clinician-specific or practice-wide.
model ClientPortalSettings {
  id                              String   @id(map: "PK_ClientPortalSettings") @db.UniqueIdentifier // Default value? // [Source: 245]
  /// Clinician these settings apply to. If null, could be practice-wide defaults (needs clarification).
  clinician_id                    String   @unique @db.UniqueIdentifier // Made unique to match BillingSettings pattern for clinician-specific overrides
  /// Whether client portal is globally enabled for the practice/clinician.
  is_enabled                      Boolean  @default(false, map: "DF_ClientPortalSettings_is_client_portal_enabled") // [Source: 246]
  /// Custom domain URL for the client portal (e.g., portal.mypractice.com).
  domain_url                      String?  @db.VarChar(250) // [Source: 247]
  /// Allow clients to submit appointment requests through the portal.
  is_appointment_requests_enabled Boolean? @default(true) // [Source: 248]
  /// Available start times for appointments shown in portal, JSON array of strings (e.g., ["09:00", "09:30", "14:00"]).
  appointment_start_times         String?  @db.VarChar(250) // [Source: 249] // Store as JSON string or Text
  /// Minimum hours of advance notice required for online appointment requests (e.g., "24" for 24 hours).
  request_minimum_notice          String?  @db.VarChar(250) // [Source: 250] // Consider Int for hours
  /// Maximum days in advance clients can request appointments (e.g., "90" for 90 days).
  maximum_request_notice          String?  @db.VarChar(250) // [Source: 251] // Consider Int for days
  /// Allow new clients (not yet in the system) to request appointments.
  allow_new_clients_request       Boolean  @default(false, map: "DF_ClientPortalSettings_allow_new_clients_request")
  /// Accept requests from new individuals via the portal.
  requests_from_new_individuals   Boolean  @default(false, map: "DF_ClientPortalSettings_requests_from_new_individuals")
  /// Accept requests from new couples via the portal.
  requests_from_new_couples       Boolean  @default(false, map: "DF_ClientPortalSettings_requests_from_new_couples")
  /// Accept requests from new families/groups (contacts) via the portal.
  requests_from_new_contacts      Boolean  @default(false, map: "DF_ClientPortalSettings_requests_from_new_contacts")
  /// Require new clients to complete a prescreening form during appointment request.
  is_prescreen_new_clinets        Boolean  @default(false, map: "DF_ClientPortalSettings_is_prescreen_new_clinets") // Typo: clients
  /// Require credit card information to be on file or entered for submitting an appointment request.
  card_for_appointment_request    Boolean  @default(false, map: "DF_ClientPortalSettings_card_for_appointment_request") // [Source: 252]
  /// Allow clients to upload documents through the portal.
  is_upload_documents_allowed     Boolean  @default(false, map: "DF_ClientPortalSettings_is_upload_documents_allowed")
  /// Welcome message displayed on the client portal homepage. Supports markdown or HTML.
  welcome_message                 String?  @db.NVarChar(Max) // [Source: 253]
  // Add relation to Clinician if clinician_id is not null
}

/// Key-value store for practice-wide settings and feature flags.
/// Keys should be dot-notation for hierarchy (e.g., 'notifications.reminders.email.enabled'). Unique key.
model PracticeSettings {
  id    String @id(map: "PK_PracticeSettings") @db.UniqueIdentifier // Default value?
  /// Setting key (e.g., 'reminders.appointment.sms.enabled', 'ui.theme.darkModeDefault'). Must be unique.
  key   String @db.VarChar(250) @unique
  /// Setting value, stored as a string. JSON can be used for complex values (e.g., arrays, objects).
  value String @db.NVarChar(Max)
}

/// SMS/text message templates for various notifications.
/// Merge tag processing logic is application-side (see schema_notes.md 7.4.1).
model ReminderTextTemplates {
  id      String @id(map: "PK_ReminderTextTemplates") @db.UniqueIdentifier // Default value?
  /// Template type: 'APPOINTMENT_REMINDER', 'APPOINTMENT_CONFIRMATION', 'DOCUMENT_LINK', 'CANCELLATION_NOTICE', 'TELEHEALTH_LINK'. Unique. (Consider enum)
  type    String @db.VarChar(250) @unique
  /// Template content with merge tags (e.g., {{client_first_name}}, {{appointment_time}}).
  content String @db.Text
}

/// Contact information for people associated with appointment requests, typically used during new client intake.
/// Details are used to create Client, ClientContact, and potentially ClientGroup records.
model RequestContactItems {
  id                     String              @id(map: "PK_RequestContactItems") @db.UniqueIdentifier // Default value? // [Source: 254]
  appointment_request_id String              @db.UniqueIdentifier
  /// Type of contact person relative to the request: 'SELF' (the patient), 'GUARDIAN', 'SPOUSE', 'EMERGENCY_CONTACT', 'OTHER'. (Consider enum)
  type                   String              @db.VarChar(250)
  first_name             String              @db.VarChar(250) // [Source: 255]
  last_name              String              @db.VarChar(250)
  preferred_name         String?             @db.VarChar(250) // [Source: 256]
  /// Date of birth of the person, stored as Date only.
  date_of_birth          DateTime?           @db.Date // [Source: 257]
  email                  String              @db.VarChar(250) // Needs validation for format
  phone                  String              @db.VarChar(250) // Needs validation for format
  /// Preferred payment method: 'SELF_PAY', 'INSURANCE_PRIMARY', 'INSURANCE_SECONDARY', 'UNKNOWN'. (Consider enum)
  payment_method         String?             @db.VarChar(250) // [Source: 258]
  /// Whether the client (person for whom services are requested, if `type` is 'SELF' or if this item represents the patient) is a minor.
  is_client_minor        Boolean? // [Source: 259]
  AppointmentRequests    AppointmentRequests @relation(fields: [appointment_request_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_RequestContactItems_AppointmentRequests") // onDelete: Cascade.
}