generator client {
  provider = "prisma-client-js"
}

generator fabbrica {
  provider    = "prisma-fabbrica"
  output      = "../src/generated/fabbrica"
  noTranspile = "true"
}

datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

/// Core appointment entity representing scheduled sessions, events, or meetings.
/// Appointments are always associated with a ClientGroup (not individual clients) to support family/couple therapy.
model Appointment {
  id                       String             @id @default(dbgenerated("newid()"), map: "PK_Appointment_ID") @db.UniqueIdentifier
  /// Type of appointment: 'APPOINTMENT' (client sessions) or 'EVENT' (non-client activities).
  type                     String             @db.VarChar(50)
  title                    String?            @db.VarChar(255)
  is_all_day               Boolean            @default(false, map: "DF_Appointment_IsAllDay")
  start_date               DateTime
  end_date                 DateTime
  location_id              String?            @db.UniqueIdentifier
  created_by               String             @db.UniqueIdentifier
  /// Current status: e.g., 'SHOW', 'NO_SHOW' , 'CANCELLED' , 'LATE_CANCELLED' , 'CLINICIAN_CANCELLED'.
  status                   String             @db.VarChar(100)
  clinician_id             String?            @db.UniqueIdentifier
  /// Base fee for the appointment in dollars (before adjustments).
  appointment_fee          Decimal?
  service_id               String?            @db.UniqueIdentifier
  is_recurring             Boolean            @default(false, map: "DF_Appointment_IsRecurring")
  /// iCalendar RRULE format string defining recurrence pattern.
  recurring_rule           String?            @db.Text
  cancel_appointments      Boolean?
  notify_cancellation      Boolean?
  /// For recurring appointments: NULL if this is the parent/template, or parent's ID if this is a child instance.
  recurring_appointment_id String?            @db.UniqueIdentifier
  /// Client group (family/couple/individual) receiving services. Every 'APPOINTMENT' type is associated with a ClientGroup.
  client_group_id          String?            @db.UniqueIdentifier
  /// Session-specific fee adjustment in dollars (can be negative for discounts/credits).
  adjustable_amount        Decimal?
  superbill_id             String?            @db.UniqueIdentifier
  /// Amount written off (not expected to be collected) in dollars.
  write_off                Decimal?
  ClientGroup              ClientGroup?       @relation(fields: [client_group_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Appointment_ClientGroup")
  Clinician                Clinician?         @relation(fields: [clinician_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Appointment_Clinician")
  Location                 Location?          @relation(fields: [location_id], references: [id], map: "FK_Appointment_Location")
  PracticeService          PracticeService?   @relation(fields: [service_id], references: [id], map: "FK_Appointment_PracticeService")
  Appointment              Appointment?       @relation("AppointmentToAppointment", fields: [recurring_appointment_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Appointment_RecurringAppointment")
  other_Appointment        Appointment[]      @relation("AppointmentToAppointment")
  Superbill                Superbill?         @relation(fields: [superbill_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Appointment_Superbill")
  User                     User               @relation(fields: [created_by], references: [id], map: "FK_Appointment_User")
  AppointmentNotes         AppointmentNotes[]
  AppointmentTag           AppointmentTag[]
  Invoice                  Invoice[]
  SurveyAnswers            SurveyAnswers[]
}

/// Many-to-many junction table linking appointments with categorization tags.
model AppointmentTag {
  id             String      @id(map: "PK_AppointmentTag_ID") @default(dbgenerated("newid()"), map: "DF_AppointmentTag_ID") @db.UniqueIdentifier
  appointment_id String      @db.UniqueIdentifier
  tag_id         String      @db.UniqueIdentifier
  Appointment    Appointment @relation(fields: [appointment_id], references: [id], onUpdate: NoAction, map: "FK_AppointmentTag_Appointment")
  Tag            Tag         @relation(fields: [tag_id], references: [id], onUpdate: NoAction, map: "FK_AppointmentTag_Tag")

  @@unique([appointment_id, tag_id], map: "UQ_AppointmentTag_Appointment_Tag")
  @@index([appointment_id], map: "IX_AppointmentTag_appointment_id")
  @@index([tag_id], map: "IX_AppointmentTag_tag_id")
}

/// HIPAA compliance audit trail for tracking access and events related to protected health information (PHI).
model Audit {
  Id         String   @id(map: "PK_Audit_ID") @default(dbgenerated("newid()"), map: "DF_Audit_ID") @db.UniqueIdentifier
  /// Client whose data was accessed or affected (null for system-level events).
  client_id  String?  @db.UniqueIdentifier
  /// User who performed the action or triggered the event.
  user_id    String?  @db.UniqueIdentifier
  /// Timestamp of the event in UTC.
  datetime   DateTime @default(now(), map: "DF__Audit__datetime__17ED6F58") @db.DateTime
  /// Type of event (e.g., 'VIEW', 'UPDATE', 'DELETE', 'LOGIN_SUCCESS', 'PHI_ACCESS').
  event_type String?  @db.NChar(10)
  /// Human-readable description of the event.
  event_text String   @db.NVarChar(255)
  /// Whether this event involves HIPAA-protected information.
  is_hipaa   Boolean  @default(false, map: "DF_Audit_IsHipaa")
  Client     Client?  @relation(fields: [client_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Audit_Client")
  User       User?    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Audit_User")
}

/// Clinician availability windows for scheduling appointments.
/// Supports both one-time and recurring availability patterns.
model Availability {
  id                    String                 @id @default(dbgenerated("newid()"), map: "PK_Availability_ID") @db.UniqueIdentifier
  clinician_id          String                 @db.UniqueIdentifier
  created_at            DateTime               @default(now(), map: "DF_Availability_CreatedAt")
  updated_at            DateTime               @updatedAt
  /// Whether this availability repeats according to recurring_rule.
  is_recurring          Boolean                @default(false, map: "DF_Availability_IsRecurring")
  /// iCalendar RRULE format for recurring availability.
  recurring_rule        String?                @db.Text
  end_time              DateTime               @default(now(), map: "DF_Availability_EndTime")
  start_time            DateTime               @default(now(), map: "DF_Availability_StartTime")
  end_date              DateTime               @default(now(), map: "DF_Availability_EndDate")
  start_date            DateTime               @default(now(), map: "DF_Availability_StartDate")
  /// Display title (e.g., "Morning Hours", "Evening Availability").
  title                 String                 @db.Text
  /// Whether clients can request appointments during this time via portal.
  allow_online_requests Boolean                @default(false, map: "DF_Availability_AllowOnlineRequests")
  location_id           String                 @db.UniqueIdentifier
  /// For recurring availabilities: NULL if this is the parent/template, or parent's ID if this is a child instance.
  recurring_availability_id String?            @db.UniqueIdentifier
  Clinician             Clinician              @relation(fields: [clinician_id], references: [id], onUpdate: NoAction, map: "FK_Availability_Clinician")
  Location              Location               @relation(fields: [location_id], references: [id], onUpdate: NoAction, map: "FK_Availability_Location")
  Availability          Availability?         @relation("AvailabilityToAvailability", fields: [recurring_availability_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Availability_RecurringAvailability")
  other_Availability    Availability[]        @relation("AvailabilityToAvailability")
  AvailabilityServices  AvailabilityServices[]

  @@index([clinician_id], map: "IX_Availability_clinician_id")
  @@index([start_time, end_time], map: "IX_Availability_time_range")
}

/// Individual client (patient) record - the core entity for a person receiving services.
/// Clients are grouped into ClientGroups for appointments and billing.
model Client {
  id                       String                     @id @default(dbgenerated("newid()"), map: "PK_Client_ID") @db.UniqueIdentifier
  legal_first_name         String                     @db.VarChar(100)
  legal_last_name          String                     @db.VarChar(100)
  /// Whether client is on the practice's waitlist. If true, staff can view this client when looking for candidates for open slots.
  is_waitlist              Boolean                    @default(false, map: "DF_Client_IsWaitlist")
  primary_clinician_id     String?                    @db.UniqueIdentifier
  primary_location_id      String?                    @db.UniqueIdentifier
  created_at               DateTime                   @default(now(), map: "DF__Client__created___2FFA0313")
  /// Soft delete flag - false means client is inactive/archived.
  is_active                Boolean                    @default(true, map: "DF_Client_IsActive")
  preferred_name           String?                    @db.VarChar(100)
  date_of_birth            DateTime?                  @db.Date
  /// Portal permission: Client can request appointments online.
  allow_online_appointment Boolean                    @default(false, map: "DF_Client_allow_online_appointment")
  /// Portal permission: Client can view their invoices, statements, and superbills.
  access_billing_documents Boolean                    @default(false, map: "DF_Client_access_billing_documents")
  /// Portal permission: Client can send and receive secure messages with their clinician.
  use_secure_messaging     Boolean                    @default(false, map: "DF_Client_use_secure_messaging")
  /// Free text field for initial referral source.
  referred_by              String?                    @db.VarChar(200)
  Audit                    Audit[]
  Clinician                Clinician?                 @relation(fields: [primary_clinician_id], references: [id], onUpdate: NoAction, map: "FK_Client_Clinician")
  Location                 Location?                  @relation(fields: [primary_location_id], references: [id], onUpdate: NoAction, map: "FK_Client_Location")
  ClientAdress             ClientAdress[]
  ClientContact            ClientContact[]
  ClientFiles              ClientFiles[]
  ClientGroupMembership    ClientGroupMembership[]
  ClientProfile            ClientProfile?
  ClientReminderPreference ClientReminderPreference[]
  ClinicianClient          ClinicianClient[]
  CreditCard               CreditCard[]
  DiagnosisTreatmentPlan   DiagnosisTreatmentPlan[]
  SurveyAnswers            SurveyAnswers[]
  GoodFaithClients         GoodFaithClients[]
}

/// Extended demographic and personal information for a client.
/// Separated from main Client table to keep core data lean.
model ClientProfile {
  id                     String  @id @default(dbgenerated("newid()"), map: "PK_ClientProfile_ID") @db.UniqueIdentifier
  client_id              String  @unique @db.UniqueIdentifier
  middle_name            String? @db.VarChar(50)
  gender                 String? @db.VarChar(50)
  gender_identity        String? @db.VarChar(50)
  relationship_status    String? @db.VarChar(50)
  employment_status      String? @db.VarChar(50)
  race_ethnicity         String? @db.Text
  race_ethnicity_details String? @db.VarChar(50)
  preferred_language     String? @db.VarChar(50)
  notes                  String? @db.Text
  Client                 Client  @relation(fields: [client_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientProfile_Client")
}

/// Physical addresses associated with a client.
model ClientAdress {
  id            String  @id @default(dbgenerated("newid()"), map: "PK_ClientAddress_ID") @db.UniqueIdentifier
  client_id     String  @db.UniqueIdentifier
  address_line1 String  @db.VarChar(255)
  address_line2 String  @db.VarChar(255)
  zip_code      String  @db.VarChar(50)
  city          String  @db.VarChar(50)
  state         String  @db.VarChar(50)
  country       String  @db.VarChar(50)
  /// Whether this is the client's primary address.
  is_primary    Boolean @default(false, map: "DF_ClientAddress_IsPrimary")
  Client        Client  @relation(fields: [client_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientAddress_Client")
}

/// Contact methods for a client (email, phone, etc.).
model ClientContact {
  id                       String                     @id @default(dbgenerated("newid()"), map: "PK_ClientContact_ID") @db.UniqueIdentifier
  client_id                String                     @db.UniqueIdentifier
  /// Whether this is the primary contact method for its category.
  is_primary               Boolean                    @default(false, map: "DF_ClientContact_IsPrimary")
  /// Permission level: who can use this contact (e.g., 'CLIENT_ONLY', 'EMERGENCY_CONTACT_ONLY').
  permission               String                     @db.VarChar(50)
  /// Category of contact method: 'EMAIL', 'PHONE', 'SMS'.
  contact_type             String                     @db.VarChar(50)
  /// Subcategory or usage label: 'HOME', 'WORK', 'MOBILE', 'OTHER'.
  type                     String                     @db.VarChar(50)
  /// The actual contact value (e.g., email address, phone number).
  value                    String                     @db.VarChar(255)
  Client                   Client                     @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_ClientContact_Client")
  ClientReminderPreference ClientReminderPreference[]
}

/// Groups of clients for scheduling and billing purposes. Every appointment is associated with a ClientGroup.
/// Types: 'individual' (single client), 'couple', 'family', 'minor' (child with guardian(s)).
model ClientGroup {
  id                             String                     @id(map: "PK_ClientGroup_ID") @db.UniqueIdentifier
  /// Group type: 'individual', 'couple', 'family', 'minor'.
  type                           String                     @db.VarChar(150)
  name                           String                     @db.VarChar(250)
  clinician_id                   String?                    @db.UniqueIdentifier
  is_active                      Boolean                    @default(true, map: "DF_ClientGroup_IsActive")
  /// Total credit balance available for this group in dollars.
  available_credit               Decimal                    @default(0)
  created_at                     DateTime?                  @default(now(), map: "ClientGroup_created_at")
  auto_monthly_statement_enabled Boolean?                   @default(false, map: "DF_ClientGroup_auto_monthly_statement_enabled")
  auto_monthly_superbill_enabled Boolean?                   @default(false, map: "DF_ClientGroup_auto_monthly_superbill_enabled")
  first_seen_at                  DateTime?                  @default(now(), map: "ClientGroup_first_seen_at")
  notes                          String?                    @db.Text
  administrative_notes           String?                    @db.Text
  Appointment                    Appointment[]
  ClientBillingPreferences       ClientBillingPreferences[]
  Clinician                      Clinician?                 @relation(fields: [clinician_id], references: [id], onUpdate: NoAction, map: "FK_ClientGroup_Clinician")
  ClientGroupFile                ClientGroupFile[]
  ClientGroupMembership          ClientGroupMembership[]
  ClientGroupServices            ClientGroupServices[]
  DiagnosisTreatmentPlan         DiagnosisTreatmentPlan[]
  GoodFaithEstimate              GoodFaithEstimate[]
  Invoice                        Invoice[]
  Statement                      Statement[]
  Superbill                      Superbill[]
  SurveyAnswers                  SurveyAnswers[]
  ClientGroupChartNote           ClientGroupChartNote[]
}

/// Junction table linking clients to groups with role information.
model ClientGroupMembership {
  client_group_id            String      @default(dbgenerated("newid()"), map: "DF_ClientGroupMembership_ID") @db.UniqueIdentifier
  client_id                  String      @db.UniqueIdentifier
  role                       String?     @db.VarChar(50)
  created_at                 DateTime    @default(now(), map: "DF__GroupClie__creat__6EEB59C5")
  is_contact_only            Boolean     @default(false, map: "DF_ClientGroupMembership_IsContactOnly")
  /// Whether this member is responsible for billing for the group.
  is_responsible_for_billing Boolean?
  is_emergency_contact       Boolean?    @default(false, map: "DF_ClientGroupMembership_IsEmergencyContactOnly")
  Client                     Client      @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_ClientGroupMembership_Client")
  ClientGroup                ClientGroup @relation(fields: [client_group_id], references: [id], onUpdate: NoAction, map: "FK_ClientGroupMembership_ClientGroup")

  @@id([client_group_id, client_id], map: "PK_ClientGroupMembership_ID")
  @@index([client_id], map: "IX_ClientGroupMembership_client_id")
}

model ClientGroupChartNote {
  id                 String        @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  text               String        @db.Text
  client_group_id    String        @db.UniqueIdentifier
  note_date          DateTime      @default(now())
  ClientGroup        ClientGroup   @relation(fields: [client_group_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientGroupChartNote_ClientGroup")

  @@index([client_group_id], map: "IX_ClientGroupChartNote_client_group_id")
}

/// Client preferences for appointment reminders and notifications.
model ClientReminderPreference {
  id            String        @id @default(dbgenerated("newid()"), map: "PK_ClientReminderPreference_ID") @db.UniqueIdentifier
  client_id     String        @db.UniqueIdentifier
  /// Type of reminder: 'APPOINTMENT', 'BILLING', 'FORM_DUE', etc.
  reminder_type String        @db.VarChar(100)
  is_enabled    Boolean       @default(true, map: "DF_ClientReminderPreference_IsEnabled")
  channel       String
  contact_id    String        @db.UniqueIdentifier
  Client        Client        @relation(fields: [client_id], references: [id], onDelete: Cascade, map: "FK_ClientReminderPreference_Client")
  ClientContact ClientContact @relation(fields: [contact_id], references: [id], onDelete: Cascade, map: "FK_ClientReminderPreference_ClientContact")

  @@unique([client_id, reminder_type, channel])
}

/// Billing addresses for clinicians (for insurance claims and billing).
model BillingAddress {
  id           String    @id @default(dbgenerated("newid()"), map: "PK_BillingAddress_ID") @db.UniqueIdentifier
  street       String    @db.VarChar(255)
  city         String    @db.VarChar(100)
  state        String    @db.VarChar(50)
  zip          String    @db.VarChar(20)
  /// Address type: 'SERVICE_LOCATION' or 'PAY_TO_ADDRESS'.
  type         String    @db.VarChar(50)
  clinician_id String    @db.UniqueIdentifier
  Clinician    Clinician @relation("ManyBillingAddresses", fields: [clinician_id], references: [id], onDelete: Cascade, map: "FK_BillingAddress_Clinician")

  @@unique([clinician_id, type], map: "UQ_BillingAddress_Clinician_Type")
  @@index([clinician_id], map: "IX_BillingAddress_clinician_id")
}

/// Healthcare provider who delivers services to clients.
model Clinician {
  id                  String                @id @default(dbgenerated("newid()"), map: "PK_Clinician_ID") @db.UniqueIdentifier
  user_id             String                @unique @db.UniqueIdentifier
  address             String                @db.Text
  /// Revenue split percentage for this clinician.
  percentage_split    Float
  is_active           Boolean               @default(true, map: "DF_Clinician_IsActive")
  first_name          String                @db.VarChar(100)
  last_name           String                @db.VarChar(100)
  speciality          String?               @db.VarChar(250)
  /// National Provider Identifier for insurance billing.
  NPI_number          String?               @db.VarChar(250)
  taxonomy_code       String?               @db.VarChar(250)
  Appointment         Appointment[]
  appointmentLimits   AppointmentLimit[]
  Availability        Availability[]
  billingAddresses    BillingAddress[]      @relation("ManyBillingAddresses")
  billingSettings     BillingSettings?
  Client              Client[]
  ClientGroup         ClientGroup[]
  User                User                  @relation(fields: [user_id], references: [id], map: "FK_Clinician_User")
  ClinicianClient     ClinicianClient[]
  ClinicianLocation   ClinicianLocation[]
  ClinicianServices   ClinicianServices[]
  GoodFaithEstimate   GoodFaithEstimate[]
  Invoice             Invoice[]
  License             License[]
  PracticeInformation PracticeInformation[]
}

/// Many-to-many relationship between clinicians and clients.
model ClinicianClient {
  client_id     String    @db.UniqueIdentifier
  clinician_id  String    @db.UniqueIdentifier
  is_primary    Boolean   @default(false, map: "DF_ClinicianClient_IsPrimary")
  assigned_date DateTime  @default(now(), map: "DF__Clinician__assig__430CD787")
  Client        Client    @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_ClinicianClient_Client")
  Clinician     Clinician  @relation(fields: [clinician_id], references: [id], onUpdate: NoAction, map: "FK_ClinicianClient_Clinician")

  @@id([client_id, clinician_id], map: "PK_ClinicianClient_ID")
}

/// Many-to-many relationship between clinicians and service locations.
model ClinicianLocation {
  clinician_id String    @db.UniqueIdentifier
  location_id  String    @db.UniqueIdentifier
  is_primary   Boolean   @default(false, map: "DF_ClinicianLocation_IsPrimary")
  Clinician    Clinician @relation(fields: [clinician_id], references: [id], map: "FK_ClinicianLocation_Clinician")
  Location     Location  @relation(fields: [location_id], references: [id], map: "FK_ClinicianLocation_Location")

  @@id([clinician_id, location_id], map: "PK_ClinicianLocation_ID")
}

/// Services offered by each clinician with optional custom rates.
model ClinicianServices {
  clinician_id    String          @db.UniqueIdentifier
  service_id      String          @db.UniqueIdentifier
  /// Custom rate for this service (overrides standard service rate).
  custom_rate     Decimal?
  is_active       Boolean         @default(true, map: "DF_ClinicianServices_IsActive")
  Clinician       Clinician       @relation(fields: [clinician_id], references: [id], map: "FK_ClinicianServices_Clinician")
  PracticeService PracticeService @relation(fields: [service_id], references: [id], map: "FK_ClinicianServices_PracticeService")

  @@id([clinician_id, service_id], map: "PK_ClinicianServices_ID")
}

/// Stored payment methods for clients (tokenized for PCI compliance).
model CreditCard {
  id              String    @id @default(dbgenerated("newid()"), map: "PK_CreditCard_ID") @db.UniqueIdentifier
  client_id       String    @db.UniqueIdentifier
  card_type       String    @db.VarChar(50)
  last_four       String    @db.VarChar(4)
  expiry_month    Int
  expiry_year     Int
  cardholder_name String    @db.VarChar(100)
  is_default      Boolean   @default(false, map: "DF_CreditCard_IsDefault")
  billing_address String?   @db.Text
  /// Payment processor token (e.g., Stripe) for secure processing.
  token           String?   @db.VarChar(255)
  created_at      DateTime  @default(now(), map: "DF__CreditCar__creat__01FE2E39")
  Client          Client    @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_CreditCard_Client")
  Payment         Payment[]
}

/// Billing invoices for services rendered.
model Invoice {
  id                  String       @id @default(dbgenerated("newid()"), map: "PK_Invoice_ID") @db.UniqueIdentifier
  invoice_number      String       @db.VarChar(50)
  client_group_id     String?      @db.UniqueIdentifier
  appointment_id      String?      @db.UniqueIdentifier
  clinician_id        String?      @db.UniqueIdentifier
  issued_date         DateTime     @default(now(), map: "DF__Invoice__issued___7D39791C")
  due_date            DateTime
  amount              Decimal      @db.Decimal(10, 2)
  /// Invoice status: 'DRAFT', 'SENT', 'PAID', 'OVERDUE', 'VOID'.
  status              String       @db.VarChar(50)
  /// Invoice type: 'SERVICE', 'COPAY', 'DEDUCTIBLE', etc.
  type                String       @db.VarChar(50)
  client_info         String?      @db.Text
  notes               String?      @db.Text
  provider_info       String?      @db.Text
  service_description String?      @db.Text
  is_exported         Boolean      @default(false, map: "DF_Invoice_is_exported")
  Appointment         Appointment? @relation(fields: [appointment_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Invoice_Appointment")
  ClientGroup         ClientGroup? @relation(fields: [client_group_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Invoice_ClientGroup")
  Clinician           Clinician?   @relation(fields: [clinician_id], references: [id], onUpdate: NoAction, map: "FK_Invoice_Clinician")
  Payment             Payment[]
}

/// Physical locations where services are provided.
model Location {
  id                String              @id @default(dbgenerated("newid()"), map: "PK_Location_ID") @db.UniqueIdentifier
  name              String              @db.VarChar(255)
  address           String              @db.Text
  is_active         Boolean             @default(true, map: "DF_Location_IsActive")
  city              String?             @db.VarChar(100)
  color             String?             @db.VarChar(50)
  state             String?             @db.VarChar(100)
  street            String?             @db.VarChar(255)
  zip               String?             @db.VarChar(20)
  Appointment       Appointment[]
  Availability      Availability[]
  Client            Client[]
  ClinicianLocation ClinicianLocation[]
  GoodFaithEstimate GoodFaithEstimate[]
  GoodFaithServices GoodFaithServices[]
}

/// Payment records for invoices, tracking partial or full payments.
model Payment {
  id             String      @id @default(dbgenerated("newid()"), map: "PK_Payment_ID") @db.UniqueIdentifier
  invoice_id     String      @db.UniqueIdentifier
  payment_date   DateTime    @default(now(), map: "DF__Payment__payment__05CEBF1D")
  amount         Decimal     @db.Decimal(10, 2)
  credit_card_id String?     @db.UniqueIdentifier
  transaction_id String?     @db.VarChar(100)
  status         String      @db.VarChar(50)
  response       String?     @db.Text
  /// Amount of credit applied from ClientGroup.available_credit.
  credit_applied Decimal?    @db.Decimal(10, 2)
  CreditCard     CreditCard? @relation(fields: [credit_card_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Payment_CreditCard")
  Invoice        Invoice     @relation(fields: [invoice_id], references: [id], onUpdate: NoAction, map: "FK_Payment_Invoice")
}

/// Catalog of services offered by the practice.
model PracticeService {
  id                  String                @id @default(dbgenerated("newid()"), map: "PK_PracticeService_ID") @db.UniqueIdentifier
  type                String                @db.VarChar(255)
  /// Standard rate in dollars for this service.
  rate                Decimal               @db.Decimal(10, 2)
  /// Service code (e.g., CPT code like 90834, or internal code) for billing.
  code                String                @db.VarChar(50)
  description         String?               @db.Text
  /// Standard duration of the service in minutes.
  duration            Int
  color               String?               @db.VarChar(7)
  /// Whether new clients are allowed to book this service.
  allow_new_clients   Boolean               @default(false)
  /// Whether this service can be booked online via the client portal.
  available_online    Boolean               @default(false)
  /// Whether to bill insurance in units (e.g., 15-minute increments).
  bill_in_units       Boolean               @default(false)
  block_after         Int                   @default(0)
  block_before        Int                   @default(0)
  is_default          Boolean               @default(false)
  require_call        Boolean               @default(false)
  Appointment          Appointment[]
  AppointmentRequests  AppointmentRequests[]
  AvailabilityServices AvailabilityServices[]
  ClientGroupServices  ClientGroupServices[]
  ClinicianServices    ClinicianServices[]
  GoodFaithServices    GoodFaithServices[]
}

/// User roles for role-based access control (RBAC).
model Role {
  id             String           @id @default(dbgenerated("newid()"), map: "PK_Role_ID") @db.UniqueIdentifier
  /// Unique role identifier (e.g., 'ADMIN', 'CLINICIAN', 'STAFF').
  name           String           @unique @db.VarChar(255)
  description    String?          @db.Text
  RolePermission RolePermission[]
  UserRole       UserRole[]
}

/// Client responses to surveys, forms, and questionnaires.
/// Linked to SurveyTemplate for structure. Can be linked to an appointment or client intake process.
model SurveyAnswers {
  id                     String                   @id(map: "PK_SurveyAnswers_ID") @default(dbgenerated("newid()"), map: "DF_SurveyAnswers_ID") @db.UniqueIdentifier
  template_id            String                   @db.UniqueIdentifier
  client_id              String                   @db.UniqueIdentifier
  client_group_id        String?                  @db.UniqueIdentifier
  /// JSON content of the completed survey, storing answers to the questions from the template.
  content                String?                  @db.Text
  frequency              String?                  @db.NChar(10)
  completed_at           DateTime?
  assigned_at            DateTime                 @default(now(), map: "DF__ClientDoc__assig__4D8A65FA")
  expiry_date            DateTime?
  /// Whether this is an intake form, often part of new client onboarding.
  is_intake              Boolean                  @default(false, map: "DF_SurveyAnswers_is_intake")
  /// Current status: 'ASSIGNED', 'IN_PROGRESS', 'COMPLETED', 'EXPIRED', 'SUBMITTED'.
  status                 String                   @db.VarChar(100)
  appointment_id         String?                  @db.UniqueIdentifier
  /// Whether the client (or clinician) has digitally signed this document.
  is_signed              Boolean?
  /// Whether this document is locked from further edits (e.g., after signing).
  is_locked              Boolean?
  AppointmentNotes       AppointmentNotes[]
  ClientFiles            ClientFiles[]
  DiagnosisTreatmentPlan DiagnosisTreatmentPlan[]
  Appointment            Appointment?             @relation(fields: [appointment_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_SurveyAnswers_Appointment")
  Client                 Client                   @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_SurveyAnswers_Client")
  ClientGroup            ClientGroup?             @relation(fields: [client_group_id], references: [id], onUpdate: NoAction, map: "FK_SurveyAnswers_ClientGroup")
  SurveyTemplate         SurveyTemplate           @relation(fields: [template_id], references: [id], onUpdate: NoAction, map: "FK_SurveyAnswers_SurveyTemplate")
}

/// Templates for surveys, forms, and questionnaires (e.g., intake forms, consent forms, assessments).
model SurveyTemplate {
  id                 String          @id(map: "PK_SurveyTemplate_ID") @default(dbgenerated("newid()"), map: "DF_SurveyTemplate_ID") @db.UniqueIdentifier
  name               String          @db.VarChar(255)
  content            String          @db.Text
  frequency_options  String?         @db.NChar(10)
  is_active          Boolean         @default(true, map: "DF_SurveyTemplate_IsActive")
  created_at         DateTime        @default(now(), map: "DF__DocumentT__creat__35B2DC69")
  description        String?         @db.Text
  updated_at         DateTime
  /// Template type: 'INTAKE', 'CONSENT', 'ASSESSMENT', 'CUSTOM'.
  type               String          @db.VarChar(100)
  is_default         Boolean         @default(false, map: "DF_SurveyTemplate_is_default")
  /// Whether this template requires digital signature for completion.
  requires_signature Boolean         @default(false, map: "DF_SurveyTemplate_RequiresSignature")
  /// Whether this template can be shared with clients via portal or email.
  is_shareable       Boolean         @default(false, map: "DF_SurveyTemplate_is_shareable")
  SurveyAnswers      SurveyAnswers[]
}

model sysdiagrams {
  name         String @db.NVarChar(128)
  principal_id Int
  diagram_id   Int    @id(map: "PK_sysdiagrams_ID") @default(autoincrement())
  version      Int?
  definition   Bytes?

  @@unique([principal_id, name], map: "UK_principal_name")
}

/// Tags for categorizing appointments.
model Tag {
  id             String           @id(map: "PK_Tag_ID") @default(dbgenerated("newid()"), map: "DF_Tag_ID") @db.UniqueIdentifier
  name           String           @db.NVarChar(100)
  color          String?          @db.NVarChar(50)
  AppointmentTag AppointmentTag[]
}

/// System users including clinicians, staff, and administrators.
model User {
  id              String            @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  email           String            @unique @db.VarChar(255)
  password_hash   String            @db.VarChar(255)
  last_login      DateTime?
  date_of_birth   DateTime?         @db.Date
  phone           String?           @db.VarChar(20)
  profile_photo   String?           @db.VarChar(500)
  Appointment     Appointment[]
  Audit           Audit[]
  ClientGroupFile ClientGroupFile[]
  clinicalInfos   ClinicalInfo[]
  Clinician       Clinician?
  Statement       Statement[]
  Superbill       Superbill[]
  UserRole        UserRole[]
}

/// Many-to-many junction table for user role assignments.
model UserRole {
  user_id String @db.UniqueIdentifier
  role_id String @db.UniqueIdentifier
  Role    Role   @relation(fields: [role_id], references: [id], map: "FK_UserRole_Role")
  User    User   @relation(fields: [user_id], references: [id], map: "FK_UserRole_User")

  @@id([user_id, role_id], map: "PK_UserRole_ID")
}

/// Additional clinical information for users.
model ClinicalInfo {
  id            Int    @id @default(autoincrement())
  speciality    String
  NPI_number    Float
  taxonomy_code String
  user_id       String @db.UniqueIdentifier
  User          User   @relation(fields: [user_id], references: [id], map: "FK_clinicalInfo_User")
}

/// Professional licenses held by clinicians.
model License {
  id              String    @id(map: "PK_License") @default(dbgenerated("newid()"), map: "DF_License_id") @db.UniqueIdentifier
  clinician_id    String    @db.UniqueIdentifier
  /// Type of license (e.g., 'LCSW', 'PSYCHOLOGIST', 'MFT').
  license_type    String
  license_number  String
  expiration_date DateTime
  /// State where license is valid.
  state           String
  Clinician       Clinician @relation(fields: [clinician_id], references: [id], onUpdate: NoAction, map: "FK_License_Clinician")
}

/// Practice-wide settings and information.
model PracticeInformation {
  id             String     @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  clinician_id   String?    @db.UniqueIdentifier
  practice_name  String
  practice_email String
  time_zone      String
  practice_logo  String
  phone_numbers  String
  tele_health    Boolean
  Clinician      Clinician? @relation(fields: [clinician_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_PracticeInformation_Clinician")
}

/// Daily appointment limits per clinician to prevent overbooking.
model AppointmentLimit {
  id           String    @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  date         DateTime  @db.Date
  /// Maximum number of appointments allowed on this date.
  max_limit    Int       @default(10)
  clinician_id String    @db.UniqueIdentifier
  Clinician    Clinician @relation(fields: [clinician_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([date, clinician_id], name: "UQ_AppointmentLimit_Date_Clinician")
  @@index([clinician_id], map: "IX_AppointmentLimit_clinician_id")
  @@index([date], map: "IX_AppointmentLimit_date")
}

/// Customizable email templates for various communications.
model EmailTemplate {
  id         String   @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  name       String   @db.VarChar(255)
  subject    String   @db.VarChar(255)
  content    String   @db.Text
  /// Template category: 'REMINDER', 'BILLING', 'WELCOME', etc.
  type       String   @db.VarChar(50)
  email_type String?  @db.VarChar(250)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  created_by String   @db.UniqueIdentifier

  @@index([type])
  @@index([created_by])
}

/// Additional products/services that can be billed.
model Product {
  id    String  @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  name  String  @db.VarChar(255)
  price Decimal @db.Decimal(10, 2)
}

/// System permissions that can be assigned to roles.
model Permission {
  id             String           @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  name           String           @db.VarChar(255)
  /// Unique permission identifier (e.g., 'manage_clients', 'view_billing').
  slug           String           @unique @db.VarChar(100)
  RolePermission RolePermission[]
}

/// Many-to-many junction table linking roles with permissions.
model RolePermission {
  role_id       String     @db.UniqueIdentifier
  permission_id String     @db.UniqueIdentifier
  Permission    Permission @relation(fields: [permission_id], references: [id], onDelete: Cascade, map: "FK_RolePermission_Permission")
  Role          Role       @relation(fields: [role_id], references: [id], onDelete: Cascade, map: "FK_RolePermission_Role")

  @@id([role_id, permission_id], map: "PK_RolePermission_ID")
  @@index([role_id], map: "IX_RolePermission_role_id")
  @@index([permission_id], map: "IX_RolePermission_permission_id")
}

/// Documents and files associated with client groups.
model ClientGroupFile {
  id                 String        @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  survey_template_id String?       @db.UniqueIdentifier
  title              String        @db.VarChar(255)
  type               String        @default("PRACTICE_UPLOAD") @db.VarChar(50)
  url                String?       @db.Text
  client_group_id    String        @db.UniqueIdentifier
  uploaded_by_id     String?       @db.UniqueIdentifier
  created_at         DateTime      @default(now())
  updated_at         DateTime      @updatedAt
  is_template        Boolean       @default(false)
  original_template_id String?     @db.UniqueIdentifier
  sharing_enabled    Boolean       @default(true)
  expiry_date        DateTime?     @db.DateTime
  ClientFiles        ClientFiles[]
  ClientGroup        ClientGroup   @relation(fields: [client_group_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_ClientGroupFile_ClientGroup")
  User               User?         @relation(fields: [uploaded_by_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_ClientGroupFile_User")

  @@index([client_group_id], map: "IX_ClientGroupFile_client_group_id")
  @@index([uploaded_by_id], map: "IX_ClientGroupFile_uploaded_by_id")
}

/// Monthly billing statements for client groups.
model Statement {
  id                String          @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  statement_number  Int             @default(0)
  client_group_id   String          @db.UniqueIdentifier
  start_date        DateTime?
  end_date          DateTime?
  issued_date       DateTime?
  beginning_balance Decimal         @db.Decimal(10, 2)
  invoices_total    Decimal         @db.Decimal(10, 2)
  payments_total    Decimal         @db.Decimal(10, 2)
  ending_balance    Decimal         @db.Decimal(10, 2)
  provider_name     String?         @db.VarChar(255)
  provider_email    String?         @db.VarChar(255)
  provider_phone    String?         @db.VarChar(255)
  client_group_name String          @db.VarChar(255)
  client_name       String          @db.VarChar(255)
  client_email      String?         @db.VarChar(255)
  created_at        DateTime        @default(now())
  created_by        String?         @db.UniqueIdentifier
  /// Whether this statement has been exported to external billing system.
  is_exported       Boolean         @default(false, map: "DF_Statement_is_exported")
  ClientGroup       ClientGroup     @relation(fields: [client_group_id], references: [id], onUpdate: NoAction, map: "FK_Statement_ClientGroup")
  User              User?           @relation(fields: [created_by], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Statement_User")
  StatementItem     StatementItem[]

  @@index([client_group_id], map: "IX_Statement_client_group_id")
}

/// Superbills for insurance reimbursement claims.
model Superbill {
  id               String        @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  superbill_number Int           @default(0)
  client_group_id  String        @db.UniqueIdentifier
  issued_date      DateTime      @default(now())
  provider_name    String?       @db.VarChar(255)
  provider_email   String?       @db.VarChar(255)
  provider_license String?       @db.VarChar(100)
  client_name      String        @db.VarChar(255)
  status           String        @db.VarChar(50)
  created_at       DateTime      @default(now())
  created_by       String?       @db.UniqueIdentifier
  is_exported      Boolean       @default(false, map: "DF_Superbill_is_exported")
  Appointment      Appointment[]
  ClientGroup      ClientGroup   @relation(fields: [client_group_id], references: [id], onUpdate: NoAction, map: "FK_Superbill_ClientGroup")
  User             User?         @relation(fields: [created_by], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Superbill_User")

  @@index([client_group_id], map: "IX_Superbill_client_group_id")
}

/// Clinician-specific billing configuration.
model BillingSettings {
  id                                   String     @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  clinician_id                         String?    @unique @db.UniqueIdentifier
  autoInvoiceCreation                  String?    @db.VarChar(50)
  pastDueDays                          Int?
  emailClientPastDue                   Boolean?
  invoiceIncludePracticeLogo           Boolean?
  invoiceFooterInfo                    String?    @db.VarChar(120)
  superbillDayOfMonth                  Int?
  superbillIncludePracticeLogo         Boolean?
  superbillIncludeSignatureLine        Boolean?
  superbillIncludeDiagnosisDescription Boolean?
  superbillFooterInfo                  String?    @db.VarChar(120)
  billingDocEmailDelayMinutes          Int?
  createMonthlyStatementsForNewClients Boolean?
  createMonthlySuperbillsForNewClients Boolean?
  defaultNotificationMethod            String?    @db.VarChar(50)
  created_at                           DateTime   @default(now())
  updated_at                           DateTime   @updatedAt
  Clinician                            Clinician? @relation(fields: [clinician_id], references: [id], onDelete: Cascade)

  @@index([clinician_id])
}

/// Clinical notes linked to appointments and survey answers.
model AppointmentNotes {
  id                 String        @id(map: "PK_AppointmentNotes") @db.UniqueIdentifier
  appointment_id     String        @db.UniqueIdentifier
  type               String        @db.VarChar(50)
  survey_answer_id   String        @db.UniqueIdentifier
  created_by         String?       @db.UniqueIdentifier
  /// Whether the note has been signed by the clinician.
  is_signed          Boolean       @default(false, map: "DF_AppointmentNotes_is_signed")
  unlocked_by        String?       @db.UniqueIdentifier
  unlocked_time      DateTime?
  signed_name        String?       @db.VarChar(250)
  signed_credentials String?       @db.VarChar(250)
  signed_time        DateTime?
  signed_ipaddress   String?       @db.VarChar(50)
  Appointment        Appointment   @relation(fields: [appointment_id], references: [id], onUpdate: NoAction, map: "FK_AppointmentNotes_Appointment")
  SurveyAnswers      SurveyAnswers @relation(fields: [survey_answer_id], references: [id], onUpdate: NoAction, map: "FK_AppointmentNotes_SurveyAnswers")
}

/// Client group preferences for receiving billing documents.
model ClientBillingPreferences {
  id                         String      @id(map: "PK_ClientBillingPreferences") @db.UniqueIdentifier
  client_group_id            String      @db.UniqueIdentifier
  email_generated_invoices   Boolean     @default(false, map: "DF_ClientBillingPreferences_email_generated_invoices")
  email_generated_statements Boolean     @default(false, map: "DF_ClientBillingPreferences_email_generated_statements")
  email_generated_superbills Boolean     @default(false, map: "DF_ClientBillingPreferences_email_generated_superbills")
  notify_new_invoices        Boolean     @default(false, map: "DF_ClientBillingPreferences_notify_new_invoices")
  notify_new_statements      Boolean     @default(false, map: "DF_ClientBillingPreferences_notify_new_statements")
  notify_new_superbills      Boolean     @default(false, map: "DF_ClientBillingPreferences_notify_new_superbills")
  ClientGroup                ClientGroup @relation(fields: [client_group_id], references: [id], onUpdate: NoAction, map: "FK_ClientBillingPreferences_ClientGroup")
}

/// Links between clients and files in their group.
model ClientFiles {
  id                   String          @id(map: "PK_ClientFiles") @db.UniqueIdentifier
  client_group_file_id String          @db.UniqueIdentifier
  client_id            String          @db.UniqueIdentifier
  status               String          @db.VarChar(50)
  survey_answers_id    String?         @db.UniqueIdentifier
  frequency            String?         @db.VarChar(50)
  next_due_date        DateTime?       @db.DateTime
  shared_at            DateTime?       @db.DateTime
  completed_at         DateTime?       @db.DateTime
  Client               Client          @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_ClientFiles_Client")
  ClientGroupFile      ClientGroupFile @relation(fields: [client_group_file_id], references: [id], onUpdate: NoAction, map: "FK_ClientFiles_ClientGroupFile")
  SurveyAnswers        SurveyAnswers?  @relation(fields: [survey_answers_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_ClientFiles_SurveyAnswers")
}

/// Custom service rates for specific client groups.
model ClientGroupServices {
  id              String          @id(map: "PK_ClientGroupServices") @db.UniqueIdentifier
  client_group_id String          @db.UniqueIdentifier
  service_id      String          @db.UniqueIdentifier
  custom_rate     Decimal
  ClientGroup     ClientGroup     @relation(fields: [client_group_id], references: [id], onUpdate: NoAction, map: "FK_ClientGroupServices_ClientGroup")
  PracticeService PracticeService @relation(fields: [service_id], references: [id], onUpdate: NoAction, map: "FK_ClientGroupServices_PracticeService")
}

/// ICD-10 diagnosis codes used in treatment planning and billing.
model Diagnosis {
  id                         String                       @id(map: "PK__Diagnosi__3213E83FF84A10BA") @default(dbgenerated("newid()"), map: "DF__Diagnosis__id__4F688CCB") @db.UniqueIdentifier
  code                       String                       @db.VarChar(50)
  description                String                       @db.VarChar(255)
  DiagnosisTreatmentPlanItem DiagnosisTreatmentPlanItem[]
  GoodFaithServices          GoodFaithServices[]

  @@index([code], map: "IX_Diagnosis_Code")
}

/// Treatment plans linking clients with diagnoses.
model DiagnosisTreatmentPlan {
  id                         String                       @id(map: "PK__Diagnosi__3213E83FDFE52E56") @default(dbgenerated("newid()"), map: "DF__DiagnosisTre__id__5244F976") @db.UniqueIdentifier
  client_id                  String                       @db.UniqueIdentifier
  client_group_id            String?                      @db.UniqueIdentifier
  created_at                 DateTime                     @default(now(), map: "DF__Diagnosis__creat__53391DAF") @db.DateTime
  updated_at                 DateTime?                    @db.DateTime
  is_signed                  String?                      @default("0", map: "DF_DiagnosisTreatmentPlan_is_signed") @db.NChar(10)
  title                      String                       @db.VarChar(255)
  survey_answers_id          String?                      @db.UniqueIdentifier
  Client                     Client                       @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_DiagnosisTreatmentPlan_Client")
  ClientGroup                ClientGroup?                 @relation(fields: [client_group_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_DiagnosisTreatmentPlan_ClientGroup")
  SurveyAnswers              SurveyAnswers?               @relation(fields: [survey_answers_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_DiagnosisTreatmentPlan_SurveyAnswers")
  DiagnosisTreatmentPlanItem DiagnosisTreatmentPlanItem[]

  @@index([client_id], map: "IX_DiagnosisTreatmentPlan_ClientId")
  @@index([client_group_id], map: "IX_DiagnosisTreatmentPlan_ClientGroupId")
  @@index([survey_answers_id], map: "IX_DiagnosisTreatmentPlan_SurveyAnswersId")
}

/// Individual diagnosis items within a treatment plan.
model DiagnosisTreatmentPlanItem {
  id                     String                 @id(map: "PK__Diagnosi__3213E83F425BBD2A") @default(dbgenerated("newid()"), map: "DF__DiagnosisTre__id__58F1F705") @db.UniqueIdentifier
  treatment_plan_id      String                 @db.UniqueIdentifier
  diagnosis_id           String                 @db.UniqueIdentifier
  custom_description     String?                @db.VarChar(255)
  Diagnosis              Diagnosis              @relation(fields: [diagnosis_id], references: [id], onUpdate: NoAction, map: "FK_DiagnosisTreatmentPlanItem_Diagnosis")
  DiagnosisTreatmentPlan DiagnosisTreatmentPlan @relation(fields: [treatment_plan_id], references: [id], onUpdate: NoAction, map: "FK_DiagnosisTreatmentPlanItem_DiagnosisTreatmentPlan")

  @@index([diagnosis_id], map: "IX_DiagnosisTreatmentPlanItem_DiagnosisId")
  @@index([treatment_plan_id], map: "IX_DiagnosisTreatmentPlanItem_TreatmentPlanId")
}

/// Good faith estimates for uninsured clients (No Surprises Act compliance).
model GoodFaithEstimate {
  id                    String              @id(map: "PK_GoodFaithEstimate") @default(dbgenerated("newid()")) @db.UniqueIdentifier
  clinician_id          String              @db.UniqueIdentifier
  client_group_id       String?             @db.UniqueIdentifier
  clinician_npi         String?             @db.VarChar(100)
  clinician_tin         String?             @db.VarChar(100)
  clinician_location_id String              @db.UniqueIdentifier
  contact_person_id     String?             @db.UniqueIdentifier
  clinician_phone       String?             @db.VarChar(50)
  clinician_email       String?             @db.VarChar(50)
  provided_date         DateTime?           @db.DateTime
  expiration_date       DateTime?           @db.DateTime
  service_start_date    DateTime?           @db.Date
  service_end_date      DateTime?           @db.Date
  /// Total estimated cost in dollars.
  total_cost            Int
  notes                 String?             @db.Text
  Clinician             Clinician           @relation(fields: [clinician_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithEstimate_Clinician")
  ClientGroup           ClientGroup?        @relation(fields: [client_group_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithEstimate_ClientGroup")
  Location              Location            @relation(fields: [clinician_location_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithEstimate_Location")
  GoodFaithServices     GoodFaithServices[]
  GoodFaithClients      GoodFaithClients[]
}

model GoodFaithClients {
  id                String            @id(map: "PK_GoodFaithClients") @default(dbgenerated("newid()")) @db.UniqueIdentifier
  client_id         String            @db.UniqueIdentifier
  good_faith_id     String            @db.UniqueIdentifier
  name              String            @db.VarChar(100)
  dob               DateTime          @db.Date 
  address           String?           @db.VarChar(250)
  city              String?           @db.VarChar(100)
  state             String?           @db.VarChar(100)
  zip_code          String?           @db.VarChar(50)
  phone             String?           @db.VarChar(50)
  email             String?           @db.VarChar(100)
  should_voice      Boolean           @default(false, map: "DF_GoodFaithClients_should_voice")
  should_text       Boolean           @default(false, map: "DF_GoodFaithClients_should_text")
  should_email      Boolean           @default(false, map: "DF_GoodFaithClients_should_email")
 
  Client            Client            @relation(fields: [client_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithClients_Client")
  GoodFaithEstimate GoodFaithEstimate @relation(fields: [good_faith_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithClients_GoodFaithEstimate")
}

/// Services included in a good faith estimate.
model GoodFaithServices {
  id                String            @id(map: "PK_GoodFaithServices") @default(dbgenerated("newid()")) @db.UniqueIdentifier
  good_faith_id     String            @db.UniqueIdentifier
  service_id        String            @db.UniqueIdentifier
  diagnosis_id      String            @db.UniqueIdentifier
  location_id       String            @db.UniqueIdentifier
  quantity          Int
  fee               Int
  Diagnosis         Diagnosis         @relation(fields: [diagnosis_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithServices_Diagnosis")
  GoodFaithEstimate GoodFaithEstimate @relation(fields: [good_faith_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithServices_GoodFaithEstimate")
  Location          Location          @relation(fields: [location_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithServices_Location")
  PracticeService   PracticeService   @relation(fields: [service_id], references: [id], onUpdate: NoAction, map: "FK_GoodFaithServices_PracticeService")
}

/// Line items on billing statements.
model StatementItem {
  id           String    @id(map: "PK_StatementItem") @db.UniqueIdentifier
  statement_id String    @db.UniqueIdentifier
  date         DateTime
  description  String    @db.VarChar(255)
  charges      Int
  payments     Int
  balance      Int
  Statement    Statement @relation(fields: [statement_id], references: [id], onUpdate: NoAction, map: "FK_StatementItem_Statement")
}

/// Client requests for appointments submitted via portal.
model AppointmentRequests {
  id                       String                @id(map: "PK_AppointmentRequests") @db.UniqueIdentifier
  clinician_id             String                @db.UniqueIdentifier
  client_id                String?               @db.UniqueIdentifier
  service_id               String                @db.UniqueIdentifier
  appointment_for          String?               @db.VarChar(50)
  reasons_for_seeking_care String?               @db.Text
  mental_health_history    String?               @db.Text
  additional_notes         String?               @db.Text
  start_time               DateTime              @db.DateTime
  end_time                 DateTime              @db.DateTime
  /// Request status: 'PENDING', 'APPROVED', 'DECLINED', 'SCHEDULED'.
  status                   String                @db.VarChar(250)
  received_date            DateTime              @db.DateTime
  updated_at               DateTime?             @db.DateTime
  PracticeService          PracticeService       @relation(fields: [service_id], references: [id], onUpdate: NoAction, map: "FK_AppointmentRequests_PracticeService")
  RequestContactItems      RequestContactItems[]
}

/// Services that can be booked during specific availability windows.
model AvailabilityServices {
  availability_id String          @db.UniqueIdentifier
  service_id      String          @db.UniqueIdentifier
  Availability    Availability    @relation(fields: [availability_id], references: [id], onUpdate: NoAction, map: "FK_AvailabilityServices_Availability")
  PracticeService PracticeService @relation(fields: [service_id], references: [id], onUpdate: NoAction, map: "FK_AvailabilityServices_PracticeService")

  @@id([availability_id, service_id], map: "PK_AvailabilityServices")
}

/// Configuration for client portal features per clinician.
model ClientPortalSettings {
  id                              String   @id(map: "PK_ClientPortalSettings") @db.UniqueIdentifier
  clinician_id                    String   @db.UniqueIdentifier
  is_enabled                      Boolean  @default(false, map: "DF_ClientPortalSettings_is_client_portal_enabled")
  domain_url                      String?  @db.VarChar(250)
  is_appointment_requests_enabled Boolean?
  appointment_start_times         String?  @db.VarChar(250)
  request_minimum_notice          String?  @db.VarChar(250)
  maximum_request_notice          String?  @db.VarChar(250)
  allow_new_clients_request       Boolean  @default(false, map: "DF_ClientPortalSettings_allow_new_clients_request")
  requests_from_new_individuals   Boolean  @default(false, map: "DF_ClientPortalSettings_requests_from_new_individuals")
  requests_from_new_couples       Boolean  @default(false, map: "DF_ClientPortalSettings_requests_from_new_couples")
  requests_from_new_contacts      Boolean  @default(false, map: "DF_ClientPortalSettings_requests_from_new_contacts")
  is_prescreen_new_clinets        Boolean  @default(false, map: "DF_ClientPortalSettings_is_prescreen_new_clinets")
  card_for_appointment_request    Boolean  @default(false, map: "DF_ClientPortalSettings_card_for_appointment_request")
  is_upload_documents_allowed     Boolean  @default(false, map: "DF_ClientPortalSettings_is_upload_documents_allowed")
  welcome_message                 String?  @db.NVarChar(Max)
}

/// Key-value store for practice-wide configuration.
model PracticeSettings {
  id    String @id(map: "PK_PracticeSettings") @db.UniqueIdentifier
  key   String @db.VarChar(250)
  value String @db.NVarChar(Max)
}

/// SMS/text reminder templates.
model ReminderTextTemplates {
  id      String @id @default(dbgenerated("newid()"), map: "PK_ReminderTextTemplates") @db.UniqueIdentifier
  type    String @db.VarChar(250)
  content String @db.Text
}

/// Contact information for appointment request submitters.
model RequestContactItems {
  id                     String              @id(map: "PK_RequestContactItems") @db.UniqueIdentifier
  appointment_request_id String              @db.UniqueIdentifier
  type                   String              @db.VarChar(250)
  first_name             String              @db.VarChar(250)
  last_name              String              @db.VarChar(250)
  preferred_name         String?             @db.VarChar(250)
  date_of_birth          DateTime?           @db.Date
  email                  String              @db.VarChar(250)
  phone                  String              @db.VarChar(250)
  payment_method         String?             @db.VarChar(250)
  is_client_minor        Boolean?
  AppointmentRequests    AppointmentRequests @relation(fields: [appointment_request_id], references: [id], onUpdate: NoAction, map: "FK_RequestContactItems_AppointmentRequests")
}
